[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "inti-documentation.github.io",
    "section": "",
    "text": "Este es la documentación desarrollada para facilitar el camino para un desarrollador Fullstack Web Developer.\nThis is a Quarto website.To learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Mi nombre es Inti Luna y soy ingeniero ambiental con un gran interés en aprender a crear soluciones que integran análisis de datos y web apps.\nLinkedin\nContacto: inti.luna.aviles@gmail.com"
  },
  {
    "objectID": "index.html#qué-es-la-palabra-clave-this-en-js",
    "href": "index.html#qué-es-la-palabra-clave-this-en-js",
    "title": "inti-documentation.github.io",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "checkpoint7.html",
    "href": "checkpoint7.html",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS icon\n\n\nJavascript se diferencia de otros lenguajes (como Java, Python, C, Ruby, etc.) en que es el único que puede ser interpretado por un web browser.\nLa razón de esto es historica, en 1995 fue cuando creado por la empresa Netscape que era predominante en el mercado queria un lenguaje que pareciera como Java. Aunque inicialmente se penso para manejar Front-End y Back-End, solo ha sido exitosa en el Front-End. Aun después de la desaparición del browser de Netscape, las compañias siguientes han continuado el uso de Javascript.\nReferencias\nhttps://snipcart.com/blog/why-javascript-benefits\nhttps://en.wikipedia.org/wiki/Netscape\n\n\n\nEn JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp\n\n\n\n\nEn JS, los objeto de clase string representan texto y existen diferentes métodos que se resumen en la siguiente imagen.\n\n\n\nJS String methods\n\n\nDentro de estos metodos encontramos funcionalidades que nos permiten manipular strings que son muy utiles en la gestión de datos.\nComo ejemplo de lo múltiples metodos, vamos a asumir que hemos obtenido un texto en mínuscula pero necesitamos hacer la primera letra del titulo en mayúscula:\nlet titulo = \"hola pequeños gatos\";\n\nlet tituloCapitalizado = titulo.charAt(0).toUpperCase() + titulo.slice(1);\n\nconsole.log(tituloCapitalizado);\nAhora imaginamos que queremos hacer un split de texto, extraer el segundo objeto y removemos espacios en blanco usando trim().\n\nlet texto = \"manzana, naranja, banana\";\n\n// Dividir el texto en un array usando la coma (\",\") como separador\nlet partes = texto.split(\",\");\n\nlet segundoObjeto = partes[1].trim();\nReferencias\nhttps://www.w3schools.com/jsref/jsref_obj_string.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\n\n\n\nEn JS, una operación condicional, como el nombre indica, permite tener diferentes caminos a tomar (bloques de código a ejecutar) en dependencia de si una condición o condiciones se cumplen.\nEsto se puede entender con un ejemplo cotidiano. Digamos que vamos caminando al trabajo de manera regular pero si es tarde tenemos que tomar el metro.\n\n\n\nEjemplo condicional básico\n\n\nComo vemos, el concepto de condicional es fácil de entender y lo usamos en nuestra vida cotidiana.\nAhora en JS, la sintaxis seria:\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  console.log(`Vamos en Metro que es tarde!`);\n}\nAhora complicamos un poco más la lógica para mostrar el caso de una condicional dentro de una condicional. Por ejemplo, si fuera tarde tomamos el metro pero si es muy tarde vamos a tomar un taxi.\n\n\n\nEjemplo condicional anidado\n\n\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  if (tiempoParaTrabajar &gt; limiteMetro){\n    console.log(`Vamos en Metro que es tarde!`);\n  } else {\n    console.log(`Vamos en Taxi que es muy tarde!`);\n  }\n}\nEn caso de que hubieran multiplies condiciones a probar usamos sintaxis: “if…else if…else”.\nif (condition1)\n  statement1\nelse if (condition2)\n  statement2\nelse if (condition3)\n  statement3\n// …\nelse\n  statementN\nVeamos un ejemplo donde dependencia de la edad pagamos un precio diferente en el cine\n\nlet edad = 15;         \nlet precioBase = 10;   \nlet precioFinal;       \n\n// Aplicar descuento por edad\nif (edad &lt; 12) {\n  \n  precioFinal = precioBase * 0.5;\n} else if (edad &gt;= 12 && edad &lt; 18) {\n \n  precioFinal = precioBase * 0.75;\n} else if (edad &gt;= 65) {\n  \n  precioFinal = precioBase * 0.7;\n} else {\n \n  precioFinal = precioBase;\n}\n\n//console.log(\"El precio de la entrada es: $\" + precioFinal);\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\nhttps://www.w3schools.com/js/js_if_else.asp\n\n\n\n\n\n\nJS ternary\n\n\nEl operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if…else.\ncondicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso\nPor ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).\nPrimero veamos como seria usando condicional tipo if … else :\n\nif (lecheLitros &gt;= 5) {\n  console.log(`No comprar leche!`);\n} else {\n  console.log(`Comprar leche!`);\n}\nAhora veamos un seudo código de operación ternaria:\nHayMenosQueUmbral ? ComprarLeche : NoComprarLeche\nEn código seria algo como:\nconst umbral = 5;\nlet lecheLitros = 26;\nconst comprarLeche = lecheLitros &gt;= umbral ? \"No comprar leche\" : \"Comprar Leche\";\nconsole.log(comprarLeche); // \"No comprar leche\"\nComo vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator\nhttps://www.w3schools.com/java/java_conditions_shorthand.asp\nhttps://www.tpointtech.com/ternary-operator-in-java\n\n\n\nEn JS, se pueden definir funciones de usando declaración de función y expresión de función. Vamos a ver ejemplos y diferencias.\n\n\nLa función se define usando la palabra clave function. Se le asigna un nombre y se pueden llamar y reusar en varios sitios.\nPor ejemplo, creamos una función que suma dos números de la siguiente manera:\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\nHoisting. Las declaraciones de funciones se elevan al inicio del contexto lo que permite llamar a la función antes de escribir la declaración en el código.\n\nsumarNumeros(1,3);// 4\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\n\n\n\nEn este caso, a una variable se le asigna la función que puede ser anónima o tener un nombre interno. Por ejemplo, en la siguiente expresión creamos la variable getRectArea que contiene una función anónima:\n\nconst getRectArea = function(width, height) {\n  return width * height;\n};\n\nconsole.log(getRectArea(3, 4));\n// Expected output: 12\nUn ejemplo de función con nombre podria ser:\n\nlet funcionConNombre = function miFuncion() {\n    console.log(\"Esta es una function expression con nombre.\");\n};\n\nfuncionConNombre();  //\n// Expected output: Esta es una function expression con nombre\nNo hosting. Lo que quiere decir que no se eleva y se tiene usar después de la asignación.\nUn uso común de expresiones de función es cuando se requiere una función como valor como cuando se usan callbacks.\nCallbacks son funciones que se pasan como argumento a otra función y se ejecuta después de que ocurra un evento o se completa un proceso. Este tipo de mecánismos se usa en operaciones asíncronas como manejar eventos o esperar a una respuesta de API, ya que permite que el código continua su ejecución sin bloquearse. Por ejemplo, en en sieguiente código se espera a que ocurra un evento (click) y cuando esto ocurre, se imprime en consola un mensaje:\n\nbutton.addEventListener(\"click\", function (event) {\n  console.log(\"button is clicked!\");\n});\nEs importante observar que la secuencia de ejecución con callbacks no es la secuencia en la que estan definidas pero más bien en la secuencia en la que son llamadas.Esto permite ir llamando a funciones de manera muy dinámicas y en respuesta a las acciones de lo que podría ser las necesidades de un usuario en una web app.\nReferencias\nhttps://www.w3schools.com/js/js_function_definition.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\nhttps://www.w3schools.com/js/js_callback.asp\nhttps://www.youtube.com/watch?v=kz_vwAF4NHI\n\n\n\n\n\n\n\nJS this\n\n\nThis es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra “this” se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a this.\nVamos a ver algunos ejemplos para entender mejor como usar this:\n\nAl llamar fuera de función, se refire al objeto de ventana global.\n\n\nconsole.log('this alone', this); // [object Window]\n\nAl llamar dentro de un objeto, nos referimos al objeto.\n\n\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getThis : function() {\n      return this;\n    }\n};\n\nconsole.log('this in object method', person.getThis());\nY de la misma manera, podemos usar this para llamar a otras propiedades del objeto\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getFullName : function() {\n      return this.name + ' ' + this.lastName;\n    }\n};\n\nconsole.log('this in object method', person.getFullName());\nHay otras posibles referencias de “this” que se resumen aqui:\n\nEn un método de un objeto, this se refiere al objeto.\nPor sí solo, this se refiere al objeto global.\nEn una función, this se refiere al objeto global.\nEn una función en modo estricto, this es undefined.\nEn un evento, this se refiere al elemento que recibió el evento.\nMétodos como call(), apply() y bind() pueden asignar this a cualquier objeto.\n\nReferencias\nhttps://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.w3schools.com/js/js_this.asp\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1\n\n\n\n\n// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS"
  },
  {
    "objectID": "checkpoint7.html#qué-es-la-palabra-clave-this-en-js",
    "href": "checkpoint7.html#qué-es-la-palabra-clave-this-en-js",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS this\n\n\nThis es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra “this” se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a this.\nVamos a ver algunos ejemplos para entender mejor como usar this:\n\nAl llamar fuera de función, se refire al objeto de ventana global.\n\n\nconsole.log('this alone', this); // [object Window]\n\nAl llamar dentro de un objeto, nos referimos al objeto.\n\n\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getThis : function() {\n      return this;\n    }\n};\n\nconsole.log('this in object method', person.getThis());\nY de la misma manera, podemos usar this para llamar a otras propiedades del objeto\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getFullName : function() {\n      return this.name + ' ' + this.lastName;\n    }\n};\n\nconsole.log('this in object method', person.getFullName());\nHay otras posibles referencias de “this” que se resumen aqui:\n\nEn un método de un objeto, this se refiere al objeto.\nPor sí solo, this se refiere al objeto global.\nEn una función, this se refiere al objeto global.\nEn una función en modo estricto, this es undefined.\nEn un evento, this se refiere al elemento que recibió el evento.\nMétodos como call(), apply() y bind() pueden asignar this a cualquier objeto.\n\nReferencias\nhttps://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.w3schools.com/js/js_this.asp\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1"
  },
  {
    "objectID": "checkpoint7.html#ejercicio",
    "href": "checkpoint7.html#ejercicio",
    "title": "JS - CKP7",
    "section": "",
    "text": "// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS"
  },
  {
    "objectID": "checkpoint7.html#qué-diferencia-a-javascript-de-cualquier-otro-lenguaje-de-programación",
    "href": "checkpoint7.html#qué-diferencia-a-javascript-de-cualquier-otro-lenguaje-de-programación",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS icon\n\n\nJavascript se diferencia de otros lenguajes (como Java, Python, C, Ruby, etc.) en que es el único que puede ser interpretado por un web browser.\nLa razón de esto es historica, en 1995 fue cuando creado por la empresa Netscape que era predominante en el mercado queria un lenguaje que pareciera como Java. Aunque inicialmente se penso para manejar Front-End y Back-End, solo ha sido exitosa en el Front-End. Aun después de la desaparición del browser de Netscape, las compañias siguientes han continuado el uso de Javascript.\nReferencias\nhttps://snipcart.com/blog/why-javascript-benefits\nhttps://en.wikipedia.org/wiki/Netscape"
  },
  {
    "objectID": "checkpoint7.html#cuáles-son-algunos-tipos-de-datos-js",
    "href": "checkpoint7.html#cuáles-son-algunos-tipos-de-datos-js",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp"
  },
  {
    "objectID": "checkpoint7.html#qué-es-un-operador-ternario",
    "href": "checkpoint7.html#qué-es-un-operador-ternario",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS ternary\n\n\nEl operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if…else.\ncondicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso\nPor ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).\nPrimero veamos como seria usando condicional tipo if … else :\n\nif (lecheLitros &gt;= 5) {\n  console.log(`No comprar leche!`);\n} else {\n  console.log(`Comprar leche!`);\n}\nAhora veamos un seudo código de operación ternaria:\nHayMenosQueUmbral ? ComprarLeche : NoComprarLeche\nEn código seria algo como:\nconst umbral = 5;\nlet lecheLitros = 26;\nconst comprarLeche = lecheLitros &gt;= umbral ? \"No comprar leche\" : \"Comprar Leche\";\nconsole.log(comprarLeche); // \"No comprar leche\"\nComo vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator\nhttps://www.w3schools.com/java/java_conditions_shorthand.asp\nhttps://www.tpointtech.com/ternary-operator-in-java"
  },
  {
    "objectID": "checkpoint7.html#qué-es-un-condicional",
    "href": "checkpoint7.html#qué-es-un-condicional",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JS, una operación condicional, como el nombre indica, permite tener diferentes caminos a tomar (bloques de código a ejecutar) en dependencia de si una condición o condiciones se cumplen.\nEsto se puede entender con un ejemplo cotidiano. Digamos que vamos caminando al trabajo de manera regular pero si es tarde tenemos que tomar el metro.\n\n\n\nEjemplo condicional básico\n\n\nComo vemos, el concepto de condicional es fácil de entender y lo usamos en nuestra vida cotidiana.\nAhora en JS, la sintaxis seria:\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  console.log(`Vamos en Metro que es tarde!`);\n}\nAhora complicamos un poco más la lógica para mostrar el caso de una condicional dentro de una condicional. Por ejemplo, si fuera tarde tomamos el metro pero si es muy tarde vamos a tomar un taxi.\n\n\n\nEjemplo condicional anidado\n\n\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  if (tiempoParaTrabajar &gt; limiteMetro){\n    console.log(`Vamos en Metro que es tarde!`);\n  } else {\n    console.log(`Vamos en Taxi que es muy tarde!`);\n  }\n}\nEn caso de que hubieran multiplies condiciones a probar usamos sintaxis: “if…else if…else”.\nif (condition1)\n  statement1\nelse if (condition2)\n  statement2\nelse if (condition3)\n  statement3\n// …\nelse\n  statementN\nVeamos un ejemplo donde dependencia de la edad pagamos un precio diferente en el cine\n\nlet edad = 15;         \nlet precioBase = 10;   \nlet precioFinal;       \n\n// Aplicar descuento por edad\nif (edad &lt; 12) {\n  \n  precioFinal = precioBase * 0.5;\n} else if (edad &gt;= 12 && edad &lt; 18) {\n \n  precioFinal = precioBase * 0.75;\n} else if (edad &gt;= 65) {\n  \n  precioFinal = precioBase * 0.7;\n} else {\n \n  precioFinal = precioBase;\n}\n\n//console.log(\"El precio de la entrada es: $\" + precioFinal);\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\nhttps://www.w3schools.com/js/js_if_else.asp"
  },
  {
    "objectID": "checkpoint7.html#cuál-es-la-diferencia-entre-una-declaración-de-función-y-una-expresión-de-función",
    "href": "checkpoint7.html#cuál-es-la-diferencia-entre-una-declaración-de-función-y-una-expresión-de-función",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JS, se pueden definir funciones de usando declaración de función y expresión de función. Vamos a ver ejemplos y diferencias.\n\n\nLa función se define usando la palabra clave function. Se le asigna un nombre y se pueden llamar y reusar en varios sitios.\nPor ejemplo, creamos una función que suma dos números de la siguiente manera:\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\nHoisting. Las declaraciones de funciones se elevan al inicio del contexto lo que permite llamar a la función antes de escribir la declaración en el código.\n\nsumarNumeros(1,3);// 4\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\n\n\n\nEn este caso, a una variable se le asigna la función que puede ser anónima o tener un nombre interno. Por ejemplo, en la siguiente expresión creamos la variable getRectArea que contiene una función anónima:\n\nconst getRectArea = function(width, height) {\n  return width * height;\n};\n\nconsole.log(getRectArea(3, 4));\n// Expected output: 12\nUn ejemplo de función con nombre podria ser:\n\nlet funcionConNombre = function miFuncion() {\n    console.log(\"Esta es una function expression con nombre.\");\n};\n\nfuncionConNombre();  //\n// Expected output: Esta es una function expression con nombre\nNo hosting. Lo que quiere decir que no se eleva y se tiene usar después de la asignación.\nUn uso común de expresiones de función es cuando se requiere una función como valor como cuando se usan callbacks.\nCallbacks son funciones que se pasan como argumento a otra función y se ejecuta después de que ocurra un evento o se completa un proceso. Este tipo de mecánismos se usa en operaciones asíncronas como manejar eventos o esperar a una respuesta de API, ya que permite que el código continua su ejecución sin bloquearse. Por ejemplo, en en sieguiente código se espera a que ocurra un evento (click) y cuando esto ocurre, se imprime en consola un mensaje:\n\nbutton.addEventListener(\"click\", function (event) {\n  console.log(\"button is clicked!\");\n});\nEs importante observar que la secuencia de ejecución con callbacks no es la secuencia en la que estan definidas pero más bien en la secuencia en la que son llamadas.Esto permite ir llamando a funciones de manera muy dinámicas y en respuesta a las acciones de lo que podría ser las necesidades de un usuario en una web app.\nReferencias\nhttps://www.w3schools.com/js/js_function_definition.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\nhttps://www.w3schools.com/js/js_callback.asp\nhttps://www.youtube.com/watch?v=kz_vwAF4NHI"
  },
  {
    "objectID": "checkpoint7.html#cuáles-son-las-tres-funciones-de-string-en-js",
    "href": "checkpoint7.html#cuáles-son-las-tres-funciones-de-string-en-js",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JS, los objeto de clase string representan texto y existen diferentes métodos que se resumen en la siguiente imagen.\n\n\n\nJS String methods\n\n\nDentro de estos metodos encontramos funcionalidades que nos permiten manipular strings que son muy utiles en la gestión de datos.\nComo ejemplo de lo múltiples metodos, vamos a asumir que hemos obtenido un texto en mínuscula pero necesitamos hacer la primera letra del titulo en mayúscula:\nlet titulo = \"hola pequeños gatos\";\n\nlet tituloCapitalizado = titulo.charAt(0).toUpperCase() + titulo.slice(1);\n\nconsole.log(tituloCapitalizado);\nAhora imaginamos que queremos hacer un split de texto, extraer el segundo objeto y removemos espacios en blanco usando trim().\n\nlet texto = \"manzana, naranja, banana\";\n\n// Dividir el texto en un array usando la coma (\",\") como separador\nlet partes = texto.split(\",\");\n\nlet segundoObjeto = partes[1].trim();\nReferencias\nhttps://www.w3schools.com/jsref/jsref_obj_string.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"
  },
  {
    "objectID": "js_checkpoint8.html",
    "href": "js_checkpoint8.html",
    "title": "JS - CKP8",
    "section": "",
    "text": "JS icon\n\n\n\n\nLos bucles son una manera de repetir un proceso. Los bucles más comunes son:\n\nFor: itera sobre una secuencia de elementos, como un array o un objeto.\nWhile: repite proceso mientras se cumple una condición.Si no se cumple, no se corre el proceso ninguna vez.\nDo-While: similar al bucle While, pero se ejecuta al menos una vez antes de evaluar la condición.\n\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration\n\n\n\nEn JavaScript, const, let y var se utilizan para declarar variables, pero tienen diferencias clave en su alcance y comportamiento (hoisting, reglas de reasignación):\nHoisting: Es un comportamiento donde las declaraciones de variables se mueven a la parte superior del ambito en el que se declaran.\nvar: La variable declarada con var tiene un alcance de función o global, es decir, se aplica a toda la función en la que se declara. Puede ser redeclarada y reasignada.\nvar persona = { nombre: \"Ana\", edad: 28 };\n\nvar persona = { nombre: \"Fran\", edad: 25 };\nEjemplo de Hoisting para var donde se tiene:\n\nconsole.log(x); // undefined\nvar x = 10;\nDebido al hoisting, el código se ejecuta como si fuera la variable declarada y no asignada hasta después:\nvar x;\nconsole.log(x); // undefined\nx = 10;\nlet: La variable declarada con let tiene un alcance de bloque, es decir, se aplica solo dentro del bloque en el que se declara. Puede ser reasignada, pero no redeclarada.\nEn el siguiente ejemplo se observa como si se llama a una variable declarada dentro de función y se intenta llamar fuera del bloque nos da error:\nif (true) {\n    let nombre = \"Juan\";\n    console.log(nombre);\n}\nconsole.log(nombre); // Error: nombre is not defined\nEn otro ejemplo se usa let para declarar una variable global y luego otra local (dentro de función):\nlet edad = 25;\nif (true) {\n    let edad = 30; \n    console.log(edad); // 30\n}\nconsole.log(edad); // 25\nSe observa como la variable local solo es accesible dentro del bloque if y no afecta a la variable global.\nHoisting para let funciona diferente que para var, ya que que con let no se inicializa la variable y causa un error:\nconsole.log(number)\n// ReferenceError: Cannot access 'number' before initialization\n\nlet number = 50\nconst: La variable declarada con const también tiene un alcance de bloque, pero no puede ser reasignada ni redeclarada. Su valor es constante.\nconst edad = 30; \nedad = 35; // Error: Assignment to constant variable.\nHoisting para const es similar que para let donde no se inicializa variable y da error:\nconsole.log(number)\n// ReferenceError: Cannot access 'number' before initialization\n\nconst number = 50\nDebido a que usar variables antes de declararlas puede causar problemas, algunas veces se recomienda seguir la regla no-use-before-define o lo que es definir primero y hasta después usar.\nReferencias\nhttps://www.geeksforgeeks.org/difference-between-var-let-and-const-keywords-in-javascript/\nhttps://www.freecodecamp.org/news/differences-between-var-let-const-javascript/\nhttps://eslint.org/docs/latest/rules/no-use-before-define\n\n\n\nEn JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp\n\n\n\n\nEn JS, los objeto de clase string representan texto y existen diferentes métodos que se resumen en la siguiente imagen.\n\n\n\nJS String methods\n\n\nDentro de estos metodos encontramos funcionalidades que nos permiten manipular strings que son muy utiles en la gestión de datos.\nComo ejemplo de lo múltiples metodos, vamos a asumir que hemos obtenido un texto en mínuscula pero necesitamos hacer la primera letra del titulo en mayúscula:\nlet titulo = \"hola pequeños gatos\";\n\nlet tituloCapitalizado = titulo.charAt(0).toUpperCase() + titulo.slice(1);\n\nconsole.log(tituloCapitalizado);\nAhora imaginamos que queremos hacer un split de texto, extraer el segundo objeto y removemos espacios en blanco usando trim().\n\nlet texto = \"manzana, naranja, banana\";\n\n// Dividir el texto en un array usando la coma (\",\") como separador\nlet partes = texto.split(\",\");\n\nlet segundoObjeto = partes[1].trim();\nReferencias\nhttps://www.w3schools.com/jsref/jsref_obj_string.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\n\n\n\nEn JS, una operación condicional, como el nombre indica, permite tener diferentes caminos a tomar (bloques de código a ejecutar) en dependencia de si una condición o condiciones se cumplen.\nEsto se puede entender con un ejemplo cotidiano. Digamos que vamos caminando al trabajo de manera regular pero si es tarde tenemos que tomar el metro.\n\n\n\nEjemplo condicional básico\n\n\nComo vemos, el concepto de condicional es fácil de entender y lo usamos en nuestra vida cotidiana.\nAhora en JS, la sintaxis seria:\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  console.log(`Vamos en Metro que es tarde!`);\n}\nAhora complicamos un poco más la lógica para mostrar el caso de una condicional dentro de una condicional. Por ejemplo, si fuera tarde tomamos el metro pero si es muy tarde vamos a tomar un taxi.\n\n\n\nEjemplo condicional anidado\n\n\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  if (tiempoParaTrabajar &gt; limiteMetro){\n    console.log(`Vamos en Metro que es tarde!`);\n  } else {\n    console.log(`Vamos en Taxi que es muy tarde!`);\n  }\n}\nEn caso de que hubieran multiplies condiciones a probar usamos sintaxis: “if…else if…else”.\nif (condition1)\n  statement1\nelse if (condition2)\n  statement2\nelse if (condition3)\n  statement3\n// …\nelse\n  statementN\nVeamos un ejemplo donde dependencia de la edad pagamos un precio diferente en el cine\n\nlet edad = 15;         \nlet precioBase = 10;   \nlet precioFinal;       \n\n// Aplicar descuento por edad\nif (edad &lt; 12) {\n  \n  precioFinal = precioBase * 0.5;\n} else if (edad &gt;= 12 && edad &lt; 18) {\n \n  precioFinal = precioBase * 0.75;\n} else if (edad &gt;= 65) {\n  \n  precioFinal = precioBase * 0.7;\n} else {\n \n  precioFinal = precioBase;\n}\n\n//console.log(\"El precio de la entrada es: $\" + precioFinal);\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\nhttps://www.w3schools.com/js/js_if_else.asp\n\n\n\n\n\n\nJS ternary\n\n\nEl operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if…else.\ncondicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso\nPor ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).\nPrimero veamos como seria usando condicional tipo if … else :\n\nif (lecheLitros &gt;= 5) {\n  console.log(`No comprar leche!`);\n} else {\n  console.log(`Comprar leche!`);\n}\nAhora veamos un seudo código de operación ternaria:\nHayMenosQueUmbral ? ComprarLeche : NoComprarLeche\nEn código seria algo como:\nconst umbral = 5;\nlet lecheLitros = 26;\nconst comprarLeche = lecheLitros &gt;= umbral ? \"No comprar leche\" : \"Comprar Leche\";\nconsole.log(comprarLeche); // \"No comprar leche\"\nComo vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator\nhttps://www.w3schools.com/java/java_conditions_shorthand.asp\nhttps://www.tpointtech.com/ternary-operator-in-java\n\n\n\nEn JS, se pueden definir funciones de usando declaración de función y expresión de función. Vamos a ver ejemplos y diferencias.\n\n\nLa función se define usando la palabra clave function. Se le asigna un nombre y se pueden llamar y reusar en varios sitios.\nPor ejemplo, creamos una función que suma dos números de la siguiente manera:\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\nHoisting. Las declaraciones de funciones se elevan al inicio del contexto lo que permite llamar a la función antes de escribir la declaración en el código.\n\nsumarNumeros(1,3);// 4\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\n\n\n\nEn este caso, a una variable se le asigna la función que puede ser anónima o tener un nombre interno. Por ejemplo, en la siguiente expresión creamos la variable getRectArea que contiene una función anónima:\n\nconst getRectArea = function(width, height) {\n  return width * height;\n};\n\nconsole.log(getRectArea(3, 4));\n// Expected output: 12\nUn ejemplo de función con nombre podria ser:\n\nlet funcionConNombre = function miFuncion() {\n    console.log(\"Esta es una function expression con nombre.\");\n};\n\nfuncionConNombre();  //\n// Expected output: Esta es una function expression con nombre\nNo hosting. Lo que quiere decir que no se eleva y se tiene usar después de la asignación.\nUn uso común de expresiones de función es cuando se requiere una función como valor como cuando se usan callbacks.\nCallbacks son funciones que se pasan como argumento a otra función y se ejecuta después de que ocurra un evento o se completa un proceso. Este tipo de mecánismos se usa en operaciones asíncronas como manejar eventos o esperar a una respuesta de API, ya que permite que el código continua su ejecución sin bloquearse. Por ejemplo, en en sieguiente código se espera a que ocurra un evento (click) y cuando esto ocurre, se imprime en consola un mensaje:\n\nbutton.addEventListener(\"click\", function (event) {\n  console.log(\"button is clicked!\");\n});\nEs importante observar que la secuencia de ejecución con callbacks no es la secuencia en la que estan definidas pero más bien en la secuencia en la que son llamadas.Esto permite ir llamando a funciones de manera muy dinámicas y en respuesta a las acciones de lo que podría ser las necesidades de un usuario en una web app.\nReferencias\nhttps://www.w3schools.com/js/js_function_definition.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\nhttps://www.w3schools.com/js/js_callback.asp\nhttps://www.youtube.com/watch?v=kz_vwAF4NHI\n\n\n\n\n\n\n\nJS this\n\n\nThis es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra “this” se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a this.\nVamos a ver algunos ejemplos para entender mejor como usar this:\n\nAl llamar fuera de función, se refire al objeto de ventana global.\n\n\nconsole.log('this alone', this); // [object Window]\n\nAl llamar dentro de un objeto, nos referimos al objeto.\n\n\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getThis : function() {\n      return this;\n    }\n};\n\nconsole.log('this in object method', person.getThis());\nY de la misma manera, podemos usar this para llamar a otras propiedades del objeto\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getFullName : function() {\n      return this.name + ' ' + this.lastName;\n    }\n};\n\nconsole.log('this in object method', person.getFullName());\nHay otras posibles referencias de “this” que se resumen aqui:\n\nEn un método de un objeto, this se refiere al objeto.\nPor sí solo, this se refiere al objeto global.\nEn una función, this se refiere al objeto global.\nEn una función en modo estricto, this es undefined.\nEn un evento, this se refiere al elemento que recibió el evento.\nMétodos como call(), apply() y bind() pueden asignar this a cualquier objeto.\n\nReferencias\nhttps://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.w3schools.com/js/js_this.asp\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1\n\n\n\n\n\n\n\n\n\n\n\nCrea un bucle for en JS que imprima cada nombre en esta lista.\n  miLista = “velma”, “exploradora”, “jane”, “john”, “harry”\nCrea un bucle while que recorra la misma lista y también imprima los nombres. Nota: Recuerda crear un contador para que el ciclo no sea infinito.\n\n// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS\n\n\n\nCree una función de flecha que devuelva “Hola mundo”.\nEnlace a fichero JS"
  },
  {
    "objectID": "js_checkpoint8.html#qué-diferencia-a-javascript-de-cualquier-otro-lenguaje-de-programación",
    "href": "js_checkpoint8.html#qué-diferencia-a-javascript-de-cualquier-otro-lenguaje-de-programación",
    "title": "JS - CKP8",
    "section": "",
    "text": "JS icon\n\n\nJavascript se diferencia de otros lenguajes (como Java, Python, C, Ruby, etc.) en que es el único que puede ser interpretado por un web browser.\nLa razón de esto es historica, en 1995 fue cuando creado por la empresa Netscape que era predominante en el mercado queria un lenguaje que pareciera como Java. Aunque inicialmente se penso para manejar Front-End y Back-End, solo ha sido exitosa en el Front-End. Aun después de la desaparición del browser de Netscape, las compañias siguientes han continuado el uso de Javascript.\nReferencias\nhttps://snipcart.com/blog/why-javascript-benefits\nhttps://en.wikipedia.org/wiki/Netscape"
  },
  {
    "objectID": "js_checkpoint8.html#cuáles-son-algunos-tipos-de-datos-js",
    "href": "js_checkpoint8.html#cuáles-son-algunos-tipos-de-datos-js",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp"
  },
  {
    "objectID": "js_checkpoint8.html#cuáles-son-las-tres-funciones-de-string-en-js",
    "href": "js_checkpoint8.html#cuáles-son-las-tres-funciones-de-string-en-js",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JS, los objeto de clase string representan texto y existen diferentes métodos que se resumen en la siguiente imagen.\n\n\n\nJS String methods\n\n\nDentro de estos metodos encontramos funcionalidades que nos permiten manipular strings que son muy utiles en la gestión de datos.\nComo ejemplo de lo múltiples metodos, vamos a asumir que hemos obtenido un texto en mínuscula pero necesitamos hacer la primera letra del titulo en mayúscula:\nlet titulo = \"hola pequeños gatos\";\n\nlet tituloCapitalizado = titulo.charAt(0).toUpperCase() + titulo.slice(1);\n\nconsole.log(tituloCapitalizado);\nAhora imaginamos que queremos hacer un split de texto, extraer el segundo objeto y removemos espacios en blanco usando trim().\n\nlet texto = \"manzana, naranja, banana\";\n\n// Dividir el texto en un array usando la coma (\",\") como separador\nlet partes = texto.split(\",\");\n\nlet segundoObjeto = partes[1].trim();\nReferencias\nhttps://www.w3schools.com/jsref/jsref_obj_string.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-un-condicional",
    "href": "js_checkpoint8.html#qué-es-un-condicional",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JS, una operación condicional, como el nombre indica, permite tener diferentes caminos a tomar (bloques de código a ejecutar) en dependencia de si una condición o condiciones se cumplen.\nEsto se puede entender con un ejemplo cotidiano. Digamos que vamos caminando al trabajo de manera regular pero si es tarde tenemos que tomar el metro.\n\n\n\nEjemplo condicional básico\n\n\nComo vemos, el concepto de condicional es fácil de entender y lo usamos en nuestra vida cotidiana.\nAhora en JS, la sintaxis seria:\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  console.log(`Vamos en Metro que es tarde!`);\n}\nAhora complicamos un poco más la lógica para mostrar el caso de una condicional dentro de una condicional. Por ejemplo, si fuera tarde tomamos el metro pero si es muy tarde vamos a tomar un taxi.\n\n\n\nEjemplo condicional anidado\n\n\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  if (tiempoParaTrabajar &gt; limiteMetro){\n    console.log(`Vamos en Metro que es tarde!`);\n  } else {\n    console.log(`Vamos en Taxi que es muy tarde!`);\n  }\n}\nEn caso de que hubieran multiplies condiciones a probar usamos sintaxis: “if…else if…else”.\nif (condition1)\n  statement1\nelse if (condition2)\n  statement2\nelse if (condition3)\n  statement3\n// …\nelse\n  statementN\nVeamos un ejemplo donde dependencia de la edad pagamos un precio diferente en el cine\n\nlet edad = 15;         \nlet precioBase = 10;   \nlet precioFinal;       \n\n// Aplicar descuento por edad\nif (edad &lt; 12) {\n  \n  precioFinal = precioBase * 0.5;\n} else if (edad &gt;= 12 && edad &lt; 18) {\n \n  precioFinal = precioBase * 0.75;\n} else if (edad &gt;= 65) {\n  \n  precioFinal = precioBase * 0.7;\n} else {\n \n  precioFinal = precioBase;\n}\n\n//console.log(\"El precio de la entrada es: $\" + precioFinal);\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\nhttps://www.w3schools.com/js/js_if_else.asp"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-un-operador-ternario",
    "href": "js_checkpoint8.html#qué-es-un-operador-ternario",
    "title": "JS - CKP8",
    "section": "",
    "text": "JS ternary\n\n\nEl operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if…else.\ncondicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso\nPor ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).\nPrimero veamos como seria usando condicional tipo if … else :\n\nif (lecheLitros &gt;= 5) {\n  console.log(`No comprar leche!`);\n} else {\n  console.log(`Comprar leche!`);\n}\nAhora veamos un seudo código de operación ternaria:\nHayMenosQueUmbral ? ComprarLeche : NoComprarLeche\nEn código seria algo como:\nconst umbral = 5;\nlet lecheLitros = 26;\nconst comprarLeche = lecheLitros &gt;= umbral ? \"No comprar leche\" : \"Comprar Leche\";\nconsole.log(comprarLeche); // \"No comprar leche\"\nComo vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator\nhttps://www.w3schools.com/java/java_conditions_shorthand.asp\nhttps://www.tpointtech.com/ternary-operator-in-java"
  },
  {
    "objectID": "js_checkpoint8.html#cuál-es-la-diferencia-entre-una-declaración-de-función-y-una-expresión-de-función",
    "href": "js_checkpoint8.html#cuál-es-la-diferencia-entre-una-declaración-de-función-y-una-expresión-de-función",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JS, se pueden definir funciones de usando declaración de función y expresión de función. Vamos a ver ejemplos y diferencias.\n\n\nLa función se define usando la palabra clave function. Se le asigna un nombre y se pueden llamar y reusar en varios sitios.\nPor ejemplo, creamos una función que suma dos números de la siguiente manera:\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\nHoisting. Las declaraciones de funciones se elevan al inicio del contexto lo que permite llamar a la función antes de escribir la declaración en el código.\n\nsumarNumeros(1,3);// 4\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\n\n\n\nEn este caso, a una variable se le asigna la función que puede ser anónima o tener un nombre interno. Por ejemplo, en la siguiente expresión creamos la variable getRectArea que contiene una función anónima:\n\nconst getRectArea = function(width, height) {\n  return width * height;\n};\n\nconsole.log(getRectArea(3, 4));\n// Expected output: 12\nUn ejemplo de función con nombre podria ser:\n\nlet funcionConNombre = function miFuncion() {\n    console.log(\"Esta es una function expression con nombre.\");\n};\n\nfuncionConNombre();  //\n// Expected output: Esta es una function expression con nombre\nNo hosting. Lo que quiere decir que no se eleva y se tiene usar después de la asignación.\nUn uso común de expresiones de función es cuando se requiere una función como valor como cuando se usan callbacks.\nCallbacks son funciones que se pasan como argumento a otra función y se ejecuta después de que ocurra un evento o se completa un proceso. Este tipo de mecánismos se usa en operaciones asíncronas como manejar eventos o esperar a una respuesta de API, ya que permite que el código continua su ejecución sin bloquearse. Por ejemplo, en en sieguiente código se espera a que ocurra un evento (click) y cuando esto ocurre, se imprime en consola un mensaje:\n\nbutton.addEventListener(\"click\", function (event) {\n  console.log(\"button is clicked!\");\n});\nEs importante observar que la secuencia de ejecución con callbacks no es la secuencia en la que estan definidas pero más bien en la secuencia en la que son llamadas.Esto permite ir llamando a funciones de manera muy dinámicas y en respuesta a las acciones de lo que podría ser las necesidades de un usuario en una web app.\nReferencias\nhttps://www.w3schools.com/js/js_function_definition.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\nhttps://www.w3schools.com/js/js_callback.asp\nhttps://www.youtube.com/watch?v=kz_vwAF4NHI"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-la-palabra-clave-this-en-js",
    "href": "js_checkpoint8.html#qué-es-la-palabra-clave-this-en-js",
    "title": "JS - CKP8",
    "section": "",
    "text": "JS this\n\n\nThis es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra “this” se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a this.\nVamos a ver algunos ejemplos para entender mejor como usar this:\n\nAl llamar fuera de función, se refire al objeto de ventana global.\n\n\nconsole.log('this alone', this); // [object Window]\n\nAl llamar dentro de un objeto, nos referimos al objeto.\n\n\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getThis : function() {\n      return this;\n    }\n};\n\nconsole.log('this in object method', person.getThis());\nY de la misma manera, podemos usar this para llamar a otras propiedades del objeto\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getFullName : function() {\n      return this.name + ' ' + this.lastName;\n    }\n};\n\nconsole.log('this in object method', person.getFullName());\nHay otras posibles referencias de “this” que se resumen aqui:\n\nEn un método de un objeto, this se refiere al objeto.\nPor sí solo, this se refiere al objeto global.\nEn una función, this se refiere al objeto global.\nEn una función en modo estricto, this es undefined.\nEn un evento, this se refiere al elemento que recibió el evento.\nMétodos como call(), apply() y bind() pueden asignar this a cualquier objeto.\n\nReferencias\nhttps://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.w3schools.com/js/js_this.asp\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1"
  },
  {
    "objectID": "js_checkpoint8.html#ejercicio",
    "href": "js_checkpoint8.html#ejercicio",
    "title": "JS - CKP8",
    "section": "",
    "text": "// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS"
  },
  {
    "objectID": "js_checkpoint7.html",
    "href": "js_checkpoint7.html",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS icon\n\n\n\n\nJavascript se diferencia de otros lenguajes (como Java, Python, C, Ruby, etc.) en que es el único que puede ser interpretado por un web browser.\nLa razón de esto es historica, en 1995 fue cuando creado por la empresa Netscape que era predominante en el mercado queria un lenguaje que pareciera como Java. Aunque inicialmente se penso para manejar Front-End y Back-End, solo ha sido exitosa en el Front-End. Aun después de la desaparición del browser de Netscape, las compañias siguientes han continuado el uso de Javascript.\nReferencias\nhttps://snipcart.com/blog/why-javascript-benefits\nhttps://en.wikipedia.org/wiki/Netscape\n\n\n\nEn JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp\n\n\n\n\nEn JS, los objeto de clase string representan texto y existen diferentes métodos que se resumen en la siguiente imagen.\n\n\n\nJS String methods\n\n\nDentro de estos metodos encontramos funcionalidades que nos permiten manipular strings que son muy utiles en la gestión de datos.\nComo ejemplo de lo múltiples metodos, vamos a asumir que hemos obtenido un texto en mínuscula pero necesitamos hacer la primera letra del titulo en mayúscula:\nlet titulo = \"hola pequeños gatos\";\n\nlet tituloCapitalizado = titulo.charAt(0).toUpperCase() + titulo.slice(1);\n\nconsole.log(tituloCapitalizado);\nAhora imaginamos que queremos hacer un split de texto, extraer el segundo objeto y removemos espacios en blanco usando trim().\n\nlet texto = \"manzana, naranja, banana\";\n\n// Dividir el texto en un array usando la coma (\",\") como separador\nlet partes = texto.split(\",\");\n\nlet segundoObjeto = partes[1].trim();\nReferencias\nhttps://www.w3schools.com/jsref/jsref_obj_string.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\n\n\n\nEn JS, una operación condicional, como el nombre indica, permite tener diferentes caminos a tomar (bloques de código a ejecutar) en dependencia de si una condición o condiciones se cumplen.\nEsto se puede entender con un ejemplo cotidiano. Digamos que vamos caminando al trabajo de manera regular pero si es tarde tenemos que tomar el metro.\n\n\n\nEjemplo condicional básico\n\n\nComo vemos, el concepto de condicional es fácil de entender y lo usamos en nuestra vida cotidiana.\nAhora en JS, la sintaxis seria:\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  console.log(`Vamos en Metro que es tarde!`);\n}\nAhora complicamos un poco más la lógica para mostrar el caso de una condicional dentro de una condicional. Por ejemplo, si fuera tarde tomamos el metro pero si es muy tarde vamos a tomar un taxi.\n\n\n\nEjemplo condicional anidado\n\n\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  if (tiempoParaTrabajar &gt; limiteMetro){\n    console.log(`Vamos en Metro que es tarde!`);\n  } else {\n    console.log(`Vamos en Taxi que es muy tarde!`);\n  }\n}\nEn caso de que hubieran multiplies condiciones a probar usamos sintaxis: “if…else if…else”.\nif (condition1)\n  statement1\nelse if (condition2)\n  statement2\nelse if (condition3)\n  statement3\n// …\nelse\n  statementN\nVeamos un ejemplo donde dependencia de la edad pagamos un precio diferente en el cine\n\nlet edad = 15;         \nlet precioBase = 10;   \nlet precioFinal;       \n\n// Aplicar descuento por edad\nif (edad &lt; 12) {\n  \n  precioFinal = precioBase * 0.5;\n} else if (edad &gt;= 12 && edad &lt; 18) {\n \n  precioFinal = precioBase * 0.75;\n} else if (edad &gt;= 65) {\n  \n  precioFinal = precioBase * 0.7;\n} else {\n \n  precioFinal = precioBase;\n}\n\n//console.log(\"El precio de la entrada es: $\" + precioFinal);\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\nhttps://www.w3schools.com/js/js_if_else.asp\n\n\n\n\n\n\nJS ternary\n\n\nEl operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if…else.\ncondicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso\nPor ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).\nPrimero veamos como seria usando condicional tipo if … else :\n\nif (lecheLitros &gt;= 5) {\n  console.log(`No comprar leche!`);\n} else {\n  console.log(`Comprar leche!`);\n}\nAhora veamos un seudo código de operación ternaria:\nHayMenosQueUmbral ? ComprarLeche : NoComprarLeche\nEn código seria algo como:\nconst umbral = 5;\nlet lecheLitros = 26;\nconst comprarLeche = lecheLitros &gt;= umbral ? \"No comprar leche\" : \"Comprar Leche\";\nconsole.log(comprarLeche); // \"No comprar leche\"\nComo vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator\nhttps://www.w3schools.com/java/java_conditions_shorthand.asp\nhttps://www.tpointtech.com/ternary-operator-in-java\n\n\n\nEn JS, se pueden definir funciones de usando declaración de función y expresión de función. Vamos a ver ejemplos y diferencias.\n\n\nLa función se define usando la palabra clave function. Se le asigna un nombre y se pueden llamar y reusar en varios sitios.\nPor ejemplo, creamos una función que suma dos números de la siguiente manera:\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\nHoisting. Las declaraciones de funciones se elevan al inicio del contexto lo que permite llamar a la función antes de escribir la declaración en el código.\n\nsumarNumeros(1,3);// 4\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\n\n\n\nEn este caso, a una variable se le asigna la función que puede ser anónima o tener un nombre interno. Por ejemplo, en la siguiente expresión creamos la variable getRectArea que contiene una función anónima:\n\nconst getRectArea = function(width, height) {\n  return width * height;\n};\n\nconsole.log(getRectArea(3, 4));\n// Expected output: 12\nUn ejemplo de función con nombre podria ser:\n\nlet funcionConNombre = function miFuncion() {\n    console.log(\"Esta es una function expression con nombre.\");\n};\n\nfuncionConNombre();  //\n// Expected output: Esta es una function expression con nombre\nNo hosting. Lo que quiere decir que no se eleva y se tiene usar después de la asignación.\nUn uso común de expresiones de función es cuando se requiere una función como valor como cuando se usan callbacks.\nCallbacks son funciones que se pasan como argumento a otra función y se ejecuta después de que ocurra un evento o se completa un proceso. Este tipo de mecánismos se usa en operaciones asíncronas como manejar eventos o esperar a una respuesta de API, ya que permite que el código continua su ejecución sin bloquearse. Por ejemplo, en en sieguiente código se espera a que ocurra un evento (click) y cuando esto ocurre, se imprime en consola un mensaje:\n\nbutton.addEventListener(\"click\", function (event) {\n  console.log(\"button is clicked!\");\n});\nEs importante observar que la secuencia de ejecución con callbacks no es la secuencia en la que estan definidas pero más bien en la secuencia en la que son llamadas.Esto permite ir llamando a funciones de manera muy dinámicas y en respuesta a las acciones de lo que podría ser las necesidades de un usuario en una web app.\nReferencias\nhttps://www.w3schools.com/js/js_function_definition.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\nhttps://www.w3schools.com/js/js_callback.asp\nhttps://www.youtube.com/watch?v=kz_vwAF4NHI\n\n\n\n\n\n\n\nJS this\n\n\nThis es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra “this” se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a this.\nVamos a ver algunos ejemplos para entender mejor como usar this:\n\nAl llamar fuera de función, se refire al objeto de ventana global.\n\n\nconsole.log('this alone', this); // [object Window]\n\nAl llamar dentro de un objeto, nos referimos al objeto.\n\n\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getThis : function() {\n      return this;\n    }\n};\n\nconsole.log('this in object method', person.getThis());\nY de la misma manera, podemos usar this para llamar a otras propiedades del objeto\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getFullName : function() {\n      return this.name + ' ' + this.lastName;\n    }\n};\n\nconsole.log('this in object method', person.getFullName());\nHay otras posibles referencias de “this” que se resumen aqui:\n\nEn un método de un objeto, this se refiere al objeto.\nPor sí solo, this se refiere al objeto global.\nEn una función, this se refiere al objeto global.\nEn una función en modo estricto, this es undefined.\nEn un evento, this se refiere al elemento que recibió el evento.\nMétodos como call(), apply() y bind() pueden asignar this a cualquier objeto.\n\nReferencias\nhttps://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.w3schools.com/js/js_this.asp\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1\n\n\n\n\n// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS"
  },
  {
    "objectID": "js_checkpoint7.html#qué-diferencia-a-javascript-de-cualquier-otro-lenguaje-de-programación",
    "href": "js_checkpoint7.html#qué-diferencia-a-javascript-de-cualquier-otro-lenguaje-de-programación",
    "title": "JS - CKP7",
    "section": "",
    "text": "Javascript se diferencia de otros lenguajes (como Java, Python, C, Ruby, etc.) en que es el único que puede ser interpretado por un web browser.\nLa razón de esto es historica, en 1995 fue cuando creado por la empresa Netscape que era predominante en el mercado queria un lenguaje que pareciera como Java. Aunque inicialmente se penso para manejar Front-End y Back-End, solo ha sido exitosa en el Front-End. Aun después de la desaparición del browser de Netscape, las compañias siguientes han continuado el uso de Javascript.\nReferencias\nhttps://snipcart.com/blog/why-javascript-benefits\nhttps://en.wikipedia.org/wiki/Netscape"
  },
  {
    "objectID": "js_checkpoint7.html#cuáles-son-algunos-tipos-de-datos-js",
    "href": "js_checkpoint7.html#cuáles-son-algunos-tipos-de-datos-js",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp"
  },
  {
    "objectID": "js_checkpoint7.html#cuáles-son-las-tres-funciones-de-string-en-js",
    "href": "js_checkpoint7.html#cuáles-son-las-tres-funciones-de-string-en-js",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JS, los objeto de clase string representan texto y existen diferentes métodos que se resumen en la siguiente imagen.\n\n\n\nJS String methods\n\n\nDentro de estos metodos encontramos funcionalidades que nos permiten manipular strings que son muy utiles en la gestión de datos.\nComo ejemplo de lo múltiples metodos, vamos a asumir que hemos obtenido un texto en mínuscula pero necesitamos hacer la primera letra del titulo en mayúscula:\nlet titulo = \"hola pequeños gatos\";\n\nlet tituloCapitalizado = titulo.charAt(0).toUpperCase() + titulo.slice(1);\n\nconsole.log(tituloCapitalizado);\nAhora imaginamos que queremos hacer un split de texto, extraer el segundo objeto y removemos espacios en blanco usando trim().\n\nlet texto = \"manzana, naranja, banana\";\n\n// Dividir el texto en un array usando la coma (\",\") como separador\nlet partes = texto.split(\",\");\n\nlet segundoObjeto = partes[1].trim();\nReferencias\nhttps://www.w3schools.com/jsref/jsref_obj_string.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"
  },
  {
    "objectID": "js_checkpoint7.html#qué-es-un-condicional",
    "href": "js_checkpoint7.html#qué-es-un-condicional",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JS, una operación condicional, como el nombre indica, permite tener diferentes caminos a tomar (bloques de código a ejecutar) en dependencia de si una condición o condiciones se cumplen.\nEsto se puede entender con un ejemplo cotidiano. Digamos que vamos caminando al trabajo de manera regular pero si es tarde tenemos que tomar el metro.\n\n\n\nEjemplo condicional básico\n\n\nComo vemos, el concepto de condicional es fácil de entender y lo usamos en nuestra vida cotidiana.\nAhora en JS, la sintaxis seria:\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  console.log(`Vamos en Metro que es tarde!`);\n}\nAhora complicamos un poco más la lógica para mostrar el caso de una condicional dentro de una condicional. Por ejemplo, si fuera tarde tomamos el metro pero si es muy tarde vamos a tomar un taxi.\n\n\n\nEjemplo condicional anidado\n\n\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  if (tiempoParaTrabajar &gt; limiteMetro){\n    console.log(`Vamos en Metro que es tarde!`);\n  } else {\n    console.log(`Vamos en Taxi que es muy tarde!`);\n  }\n}\nEn caso de que hubieran multiplies condiciones a probar usamos sintaxis: “if…else if…else”.\nif (condition1)\n  statement1\nelse if (condition2)\n  statement2\nelse if (condition3)\n  statement3\n// …\nelse\n  statementN\nVeamos un ejemplo donde dependencia de la edad pagamos un precio diferente en el cine\n\nlet edad = 15;         \nlet precioBase = 10;   \nlet precioFinal;       \n\n// Aplicar descuento por edad\nif (edad &lt; 12) {\n  \n  precioFinal = precioBase * 0.5;\n} else if (edad &gt;= 12 && edad &lt; 18) {\n \n  precioFinal = precioBase * 0.75;\n} else if (edad &gt;= 65) {\n  \n  precioFinal = precioBase * 0.7;\n} else {\n \n  precioFinal = precioBase;\n}\n\n//console.log(\"El precio de la entrada es: $\" + precioFinal);\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\nhttps://www.w3schools.com/js/js_if_else.asp"
  },
  {
    "objectID": "js_checkpoint7.html#qué-es-un-operador-ternario",
    "href": "js_checkpoint7.html#qué-es-un-operador-ternario",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS ternary\n\n\nEl operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if…else.\ncondicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso\nPor ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).\nPrimero veamos como seria usando condicional tipo if … else :\n\nif (lecheLitros &gt;= 5) {\n  console.log(`No comprar leche!`);\n} else {\n  console.log(`Comprar leche!`);\n}\nAhora veamos un seudo código de operación ternaria:\nHayMenosQueUmbral ? ComprarLeche : NoComprarLeche\nEn código seria algo como:\nconst umbral = 5;\nlet lecheLitros = 26;\nconst comprarLeche = lecheLitros &gt;= umbral ? \"No comprar leche\" : \"Comprar Leche\";\nconsole.log(comprarLeche); // \"No comprar leche\"\nComo vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator\nhttps://www.w3schools.com/java/java_conditions_shorthand.asp\nhttps://www.tpointtech.com/ternary-operator-in-java"
  },
  {
    "objectID": "js_checkpoint7.html#cuál-es-la-diferencia-entre-una-declaración-de-función-y-una-expresión-de-función",
    "href": "js_checkpoint7.html#cuál-es-la-diferencia-entre-una-declaración-de-función-y-una-expresión-de-función",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JS, se pueden definir funciones de usando declaración de función y expresión de función. Vamos a ver ejemplos y diferencias.\n\n\nLa función se define usando la palabra clave function. Se le asigna un nombre y se pueden llamar y reusar en varios sitios.\nPor ejemplo, creamos una función que suma dos números de la siguiente manera:\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\nHoisting. Las declaraciones de funciones se elevan al inicio del contexto lo que permite llamar a la función antes de escribir la declaración en el código.\n\nsumarNumeros(1,3);// 4\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\n\n\n\nEn este caso, a una variable se le asigna la función que puede ser anónima o tener un nombre interno. Por ejemplo, en la siguiente expresión creamos la variable getRectArea que contiene una función anónima:\n\nconst getRectArea = function(width, height) {\n  return width * height;\n};\n\nconsole.log(getRectArea(3, 4));\n// Expected output: 12\nUn ejemplo de función con nombre podria ser:\n\nlet funcionConNombre = function miFuncion() {\n    console.log(\"Esta es una function expression con nombre.\");\n};\n\nfuncionConNombre();  //\n// Expected output: Esta es una function expression con nombre\nNo hosting. Lo que quiere decir que no se eleva y se tiene usar después de la asignación.\nUn uso común de expresiones de función es cuando se requiere una función como valor como cuando se usan callbacks.\nCallbacks son funciones que se pasan como argumento a otra función y se ejecuta después de que ocurra un evento o se completa un proceso. Este tipo de mecánismos se usa en operaciones asíncronas como manejar eventos o esperar a una respuesta de API, ya que permite que el código continua su ejecución sin bloquearse. Por ejemplo, en en sieguiente código se espera a que ocurra un evento (click) y cuando esto ocurre, se imprime en consola un mensaje:\n\nbutton.addEventListener(\"click\", function (event) {\n  console.log(\"button is clicked!\");\n});\nEs importante observar que la secuencia de ejecución con callbacks no es la secuencia en la que estan definidas pero más bien en la secuencia en la que son llamadas.Esto permite ir llamando a funciones de manera muy dinámicas y en respuesta a las acciones de lo que podría ser las necesidades de un usuario en una web app.\nReferencias\nhttps://www.w3schools.com/js/js_function_definition.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\nhttps://www.w3schools.com/js/js_callback.asp\nhttps://www.youtube.com/watch?v=kz_vwAF4NHI"
  },
  {
    "objectID": "js_checkpoint7.html#qué-es-la-palabra-clave-this-en-js",
    "href": "js_checkpoint7.html#qué-es-la-palabra-clave-this-en-js",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS this\n\n\nThis es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra “this” se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a this.\nVamos a ver algunos ejemplos para entender mejor como usar this:\n\nAl llamar fuera de función, se refire al objeto de ventana global.\n\n\nconsole.log('this alone', this); // [object Window]\n\nAl llamar dentro de un objeto, nos referimos al objeto.\n\n\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getThis : function() {\n      return this;\n    }\n};\n\nconsole.log('this in object method', person.getThis());\nY de la misma manera, podemos usar this para llamar a otras propiedades del objeto\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getFullName : function() {\n      return this.name + ' ' + this.lastName;\n    }\n};\n\nconsole.log('this in object method', person.getFullName());\nHay otras posibles referencias de “this” que se resumen aqui:\n\nEn un método de un objeto, this se refiere al objeto.\nPor sí solo, this se refiere al objeto global.\nEn una función, this se refiere al objeto global.\nEn una función en modo estricto, this es undefined.\nEn un evento, this se refiere al elemento que recibió el evento.\nMétodos como call(), apply() y bind() pueden asignar this a cualquier objeto.\n\nReferencias\nhttps://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.w3schools.com/js/js_this.asp\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1"
  },
  {
    "objectID": "js_checkpoint7.html#ejercicio",
    "href": "js_checkpoint7.html#ejercicio",
    "title": "JS - CKP7",
    "section": "",
    "text": "// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS"
  },
  {
    "objectID": "js_checkpoint8.html#cuáles-son-las-diferencias-entre-const-let-y-var",
    "href": "js_checkpoint8.html#cuáles-son-las-diferencias-entre-const-let-y-var",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JavaScript, const, let y var se utilizan para declarar variables, pero tienen diferencias clave en su alcance y comportamiento (hoisting, reglas de reasignación):\nHoisting: Es un comportamiento donde las declaraciones de variables se mueven a la parte superior del ambito en el que se declaran.\nvar: La variable declarada con var tiene un alcance de función o global, es decir, se aplica a toda la función en la que se declara. Puede ser redeclarada y reasignada.\nvar persona = { nombre: \"Ana\", edad: 28 };\n\nvar persona = { nombre: \"Fran\", edad: 25 };\nEjemplo de Hoisting para var donde se tiene:\n\nconsole.log(x); // undefined\nvar x = 10;\nDebido al hoisting, el código se ejecuta como si fuera la variable declarada y no asignada hasta después:\nvar x;\nconsole.log(x); // undefined\nx = 10;\nlet: La variable declarada con let tiene un alcance de bloque, es decir, se aplica solo dentro del bloque en el que se declara. Puede ser reasignada, pero no redeclarada.\nEn el siguiente ejemplo se observa como si se llama a una variable declarada dentro de función y se intenta llamar fuera del bloque nos da error:\nif (true) {\n    let nombre = \"Juan\";\n    console.log(nombre);\n}\nconsole.log(nombre); // Error: nombre is not defined\nEn otro ejemplo se usa let para declarar una variable global y luego otra local (dentro de función):\nlet edad = 25;\nif (true) {\n    let edad = 30; \n    console.log(edad); // 30\n}\nconsole.log(edad); // 25\nSe observa como la variable local solo es accesible dentro del bloque if y no afecta a la variable global.\nHoisting para let funciona diferente que para var, ya que que con let no se inicializa la variable y causa un error:\nconsole.log(number)\n// ReferenceError: Cannot access 'number' before initialization\n\nlet number = 50\nconst: La variable declarada con const también tiene un alcance de bloque, pero no puede ser reasignada ni redeclarada. Su valor es constante.\nconst edad = 30; \nedad = 35; // Error: Assignment to constant variable.\nHoisting para const es similar que para let donde no se inicializa variable y da error:\nconsole.log(number)\n// ReferenceError: Cannot access 'number' before initialization\n\nconst number = 50\nDebido a que usar variables antes de declararlas puede causar problemas, algunas veces se recomienda seguir la regla no-use-before-define o lo que es definir primero y hasta después usar.\nReferencias\nhttps://www.geeksforgeeks.org/difference-between-var-let-and-const-keywords-in-javascript/\nhttps://www.freecodecamp.org/news/differences-between-var-let-const-javascript/\nhttps://eslint.org/docs/latest/rules/no-use-before-define"
  },
  {
    "objectID": "js_checkpoint8.html#qué-tipo-de-bucles-hay-en-js",
    "href": "js_checkpoint8.html#qué-tipo-de-bucles-hay-en-js",
    "title": "JS - CKP8",
    "section": "",
    "text": "Los bucles son una manera de repetir un proceso. Los bucles más comunes son:\n\nFor: itera sobre una secuencia de elementos, como un array o un objeto.\nWhile: repite proceso mientras se cumple una condición.Si no se cumple, no se corre el proceso ninguna vez.\nDo-While: similar al bucle While, pero se ejecuta al menos una vez antes de evaluar la condición.\n\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-una-función-de-flecha",
    "href": "js_checkpoint8.html#qué-es-una-función-de-flecha",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JS, los objeto de clase string representan texto y existen diferentes métodos que se resumen en la siguiente imagen.\n\n\n\nJS String methods\n\n\nDentro de estos metodos encontramos funcionalidades que nos permiten manipular strings que son muy utiles en la gestión de datos.\nComo ejemplo de lo múltiples metodos, vamos a asumir que hemos obtenido un texto en mínuscula pero necesitamos hacer la primera letra del titulo en mayúscula:\nlet titulo = \"hola pequeños gatos\";\n\nlet tituloCapitalizado = titulo.charAt(0).toUpperCase() + titulo.slice(1);\n\nconsole.log(tituloCapitalizado);\nAhora imaginamos que queremos hacer un split de texto, extraer el segundo objeto y removemos espacios en blanco usando trim().\n\nlet texto = \"manzana, naranja, banana\";\n\n// Dividir el texto en un array usando la coma (\",\") como separador\nlet partes = texto.split(\",\");\n\nlet segundoObjeto = partes[1].trim();\nReferencias\nhttps://www.w3schools.com/jsref/jsref_obj_string.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-la-deconstrucción-de-variables",
    "href": "js_checkpoint8.html#qué-es-la-deconstrucción-de-variables",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JS, una operación condicional, como el nombre indica, permite tener diferentes caminos a tomar (bloques de código a ejecutar) en dependencia de si una condición o condiciones se cumplen.\nEsto se puede entender con un ejemplo cotidiano. Digamos que vamos caminando al trabajo de manera regular pero si es tarde tenemos que tomar el metro.\n\n\n\nEjemplo condicional básico\n\n\nComo vemos, el concepto de condicional es fácil de entender y lo usamos en nuestra vida cotidiana.\nAhora en JS, la sintaxis seria:\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  console.log(`Vamos en Metro que es tarde!`);\n}\nAhora complicamos un poco más la lógica para mostrar el caso de una condicional dentro de una condicional. Por ejemplo, si fuera tarde tomamos el metro pero si es muy tarde vamos a tomar un taxi.\n\n\n\nEjemplo condicional anidado\n\n\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  if (tiempoParaTrabajar &gt; limiteMetro){\n    console.log(`Vamos en Metro que es tarde!`);\n  } else {\n    console.log(`Vamos en Taxi que es muy tarde!`);\n  }\n}\nEn caso de que hubieran multiplies condiciones a probar usamos sintaxis: “if…else if…else”.\nif (condition1)\n  statement1\nelse if (condition2)\n  statement2\nelse if (condition3)\n  statement3\n// …\nelse\n  statementN\nVeamos un ejemplo donde dependencia de la edad pagamos un precio diferente en el cine\n\nlet edad = 15;         \nlet precioBase = 10;   \nlet precioFinal;       \n\n// Aplicar descuento por edad\nif (edad &lt; 12) {\n  \n  precioFinal = precioBase * 0.5;\n} else if (edad &gt;= 12 && edad &lt; 18) {\n \n  precioFinal = precioBase * 0.75;\n} else if (edad &gt;= 65) {\n  \n  precioFinal = precioBase * 0.7;\n} else {\n \n  precioFinal = precioBase;\n}\n\n//console.log(\"El precio de la entrada es: $\" + precioFinal);\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\nhttps://www.w3schools.com/js/js_if_else.asp"
  },
  {
    "objectID": "js_checkpoint8.html#qué-hace-el-operador-de-extensión-en-js",
    "href": "js_checkpoint8.html#qué-hace-el-operador-de-extensión-en-js",
    "title": "JS - CKP8",
    "section": "",
    "text": "JS ternary\n\n\nEl operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if…else.\ncondicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso\nPor ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).\nPrimero veamos como seria usando condicional tipo if … else :\n\nif (lecheLitros &gt;= 5) {\n  console.log(`No comprar leche!`);\n} else {\n  console.log(`Comprar leche!`);\n}\nAhora veamos un seudo código de operación ternaria:\nHayMenosQueUmbral ? ComprarLeche : NoComprarLeche\nEn código seria algo como:\nconst umbral = 5;\nlet lecheLitros = 26;\nconst comprarLeche = lecheLitros &gt;= umbral ? \"No comprar leche\" : \"Comprar Leche\";\nconsole.log(comprarLeche); // \"No comprar leche\"\nComo vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator\nhttps://www.w3schools.com/java/java_conditions_shorthand.asp\nhttps://www.tpointtech.com/ternary-operator-in-java"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-la-programación-orientada-a-objetos",
    "href": "js_checkpoint8.html#qué-es-la-programación-orientada-a-objetos",
    "title": "JS - CKP8",
    "section": "",
    "text": "JS this\n\n\nThis es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra “this” se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a this.\nVamos a ver algunos ejemplos para entender mejor como usar this:\n\nAl llamar fuera de función, se refire al objeto de ventana global.\n\n\nconsole.log('this alone', this); // [object Window]\n\nAl llamar dentro de un objeto, nos referimos al objeto.\n\n\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getThis : function() {\n      return this;\n    }\n};\n\nconsole.log('this in object method', person.getThis());\nY de la misma manera, podemos usar this para llamar a otras propiedades del objeto\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getFullName : function() {\n      return this.name + ' ' + this.lastName;\n    }\n};\n\nconsole.log('this in object method', person.getFullName());\nHay otras posibles referencias de “this” que se resumen aqui:\n\nEn un método de un objeto, this se refiere al objeto.\nPor sí solo, this se refiere al objeto global.\nEn una función, this se refiere al objeto global.\nEn una función en modo estricto, this es undefined.\nEn un evento, this se refiere al elemento que recibió el evento.\nMétodos como call(), apply() y bind() pueden asignar this a cualquier objeto.\n\nReferencias\nhttps://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.w3schools.com/js/js_this.asp\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1"
  },
  {
    "objectID": "js_checkpoint8.html#ejercicios",
    "href": "js_checkpoint8.html#ejercicios",
    "title": "JS - CKP8",
    "section": "",
    "text": "Crea un bucle for en JS que imprima cada nombre en esta lista.\n  miLista = “velma”, “exploradora”, “jane”, “john”, “harry”\nCrea un bucle while que recorra la misma lista y también imprima los nombres. Nota: Recuerda crear un contador para que el ciclo no sea infinito.\n\n// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS\n\n\n\nCree una función de flecha que devuelva “Hola mundo”.\nEnlace a fichero JS"
  },
  {
    "objectID": "js_checkpoint8.html#qué-tipo-de-bucles-hay-en-js-1",
    "href": "js_checkpoint8.html#qué-tipo-de-bucles-hay-en-js-1",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp"
  }
]