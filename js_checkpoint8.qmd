---
title: "JS - CKP8"
---

# Cuestionario - Javascript

![JS icon](images/js.png)

## ¿Qué tipo de bucles hay en JS?

Los bucles son una manera de repetir un proceso. Los bucles más comunes son:

* **For**: itera sobre una secuencia de elementos, como un array o un objeto.
* **While**: repite proceso mientras se cumple una condición.Si no se cumple, no se corre el proceso ninguna vez.
* **Do-While**: similar al bucle While, pero se ejecuta al menos una vez antes de evaluar la condición.


Referencias

<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration>

## ¿Cuáles son las diferencias entre const, let y var?

En JavaScript, const, let y var se utilizan para declarar variables, pero tienen diferencias clave en su alcance y comportamiento (hoisting, reglas de reasignación):

Hoisting: Es un comportamiento donde las declaraciones de variables se mueven a la parte superior del ambito en el que se declaran.

**var**: La variable declarada con var tiene un alcance de función o global, es decir, se aplica a toda la función en la que se declara. Puede ser redeclarada y reasignada.

``` default
var persona = { nombre: "Ana", edad: 28 };

var persona = { nombre: "Fran", edad: 25 };

```

Ejemplo de Hoisting para var donde se tiene:

``` default

console.log(x); // undefined
var x = 10;

```
Debido al hoisting, el código se ejecuta como si fuera la variable declarada y no asignada hasta después:

``` default
var x;
console.log(x); // undefined
x = 10;

```

**let**: La variable declarada con let tiene un alcance de bloque, es decir, se aplica solo dentro del bloque en el que se declara. Puede ser reasignada, pero no redeclarada.

En el siguiente ejemplo se observa como si se llama a una variable declarada dentro de función y se intenta llamar fuera del bloque nos da error:

``` default
if (true) {
    let nombre = "Juan";
    console.log(nombre);
}
console.log(nombre); // Error: nombre is not defined

```
En otro ejemplo se usa let para declarar una variable global y luego otra local (dentro de función):

``` default
let edad = 25;
if (true) {
    let edad = 30; 
    console.log(edad); // 30
}
console.log(edad); // 25

```
Se observa como la variable local solo es accesible dentro del bloque if y no afecta a la variable global.

Hoisting para let funciona diferente que para var, ya que que con let no se inicializa la variable y causa un error:


``` default
console.log(number)
// ReferenceError: Cannot access 'number' before initialization

let number = 50
```


**const**: La variable declarada con const también tiene un alcance de bloque, pero no puede ser reasignada ni redeclarada. Su valor es constante.

``` default
const edad = 30; 
edad = 35; // Error: Assignment to constant variable.

```
Hoisting para const es similar que para let donde no se inicializa variable y da error:

``` default
console.log(number)
// ReferenceError: Cannot access 'number' before initialization

const number = 50

```

Debido a que usar variables antes de declararlas puede causar problemas, algunas veces se recomienda seguir la regla **no-use-before-define** o lo que es definir primero y hasta después usar.


Referencias

<https://www.geeksforgeeks.org/difference-between-var-let-and-const-keywords-in-javascript/>

<https://www.freecodecamp.org/news/differences-between-var-let-const-javascript/>

<https://eslint.org/docs/latest/rules/no-use-before-define>



## ¿Qué es una función de flecha?

Una función flecha es una forma concisa de definir una función en JavaScript. Se utiliza la sintaxis () => {} para crear una función anónima.

Ejemplo de una función normal (function declaration) que suma dos números:

``` default
function sumar(a, b) {
  return a + b;
}

```

La versión con función anónima:

``` default
var sumar = function(a, b) {
  return a + b;
}

```

Ahora miramos versión de función flecha equivalente:


``` default
const sumar = (a, b) => a + b;
console.log(sumar(2, 3)); // 5
```
**Variantes**

Hay algunas variantes, por ejemplo los parentesis en los argumentos. En la función anterior usamos como argumentos (a,b) que nos regresa el resultado de expresión (a+b) pero en caso de que hubiera un solo argumento, los parentesis pueden ser omitidos. Por ejemplo en la siguiente expression la función puede ser escrita con o sin parentesis.

``` default
let double = n => n * 2;
// igual que: let double = (n) => n * 2;
// Muy similar a funcion anónima: let double = function(n) { return n * 2 }

alert( double(3) ); // 6
```

En caso de que no hubiera argumentos, los parentesis tienen que estar vacios. Por ejemplo:

``` default
let saluda = () => alert("Hola");
saluda();
```

**Multilinea**.En caso de que se tenga que realizar varias expresiones dentro de la función se usa "{}" para englobar la diferentes lineas y se debe incluir "return" para que nos regrese algo, justo como en función normal. Veamos un ejemplo donde se evalua que los valores pasados a función son positivos y luego calcula el área:

``` default
const calcularArea = (base, altura) => {
  if (base <= 0 || altura <= 0) {
    throw new Error("La base y la altura deben ser números positivos");
  }
  const area = base * altura;
  return area;
}
```




**Cuándo usar funciones flecha**

Se recomienda usar funciones flecha en los siguientes casos:

- Funciones cortas y simples: Cuando la función es muy simple y no requiere una gran cantidad de código, las funciones flecha son ideales.
- Callbacks: Las funciones flecha son útiles como callbacks, ya que son más concisas y fáciles de leer.
- Funciones anónimas: Las funciones flecha son una forma natural de crear funciones anónimas.
- Map, filter, reduce: Las funciones flecha son ideales para usar con métodos de arrays como map, filter y reduce.

Ejemplo de uso con map:

``` default
const numbers = [1, 2, 3, 4, 5];
const doubles = numbers.map((num) => num * 2);
console.log(doubles); // [2, 4, 6, 8, 10]

```



Referencias

<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions>

<https://www.w3schools.com/js/js_arrow_function.asp>

<https://javascript.info/arrow-functions-basics>

## ¿Qué es la deconstrucción de variables?

![Tomado de www.samanthaming.com](images/js_deconstruction.png)

La deconstrucción de variables es una forma de asignar valores a variables a partir de un objeto o un array. 

Se utiliza la sintaxis para objeto:
      `{ variable1, variable2, ... } = objeto`

Se utiliza la sintaxis para array:
      `[variable1, variable2, ...] = array`.
      
La deconstrucción de variables es útil para simplificar el código y evitar la necesidad de acceder a las propiedades de un objeto o los elementos de un array mediante su índice o nombre.

Veamos como funciona con algunos ejemplos:

```javascript
// Deconstrucción de objeto
const persona = { nombre: "Juan", edad: 30 };
const { nombre, edad } = persona;

console.log(nombre); // Output: "Juan"
console.log(edad); // Output: 30

```

Y para un array tenemos:
```javascript
// Deconstrucción de array
const frutas = ["manzana", "banana", "naranja"];
const [fruta1, fruta2, fruta3] = frutas;

console.log(fruta1); // Output: "manzana"
console.log(fruta2); // Output: "banana"
console.log(fruta3); // Output: "naranja"
```

**Valores predeterminados**

A una variable se le puede asignar un valor predeterminado, en el caso de que el valor desempacado del arreglo sea undefined.

Veamos un ejemplo para objeto donde se desestructura el objeto persona y se asignan valores predeterminados a las variables nombre, edad y pais. Si el objeto persona no tiene una propiedad con el nombre correspondiente, se asigna el valor predeterminado.

```javascript
const persona = { nombre: "Juan", edad: 30 };
const { nombre = "Desconocido", edad = 0, pais = "No especificado" } = persona;

console.log(nombre); // "Juan"
console.log(edad);   // 30
console.log(pais);   // "No especificado"
```
Ahora veamos un ejemplo usando array donde se desestructura el array colores y se asignan valores predeterminados a las variables primero, segundo y tercero. Si el array colores no tiene suficientes elementos, se asignan los valores predeterminados a las variables restantes.

``` default
const colores = ["rojo", "azul"];
const [primero = "negro", segundo = "blanco", tercero = "gris"] = colores;

console.log(primero); // "rojo"
console.log(segundo); // "azul"
console.log(tercero); // "gris"

```

**Ignorar valores devueltos**

Se puede ignorar los valores que no interesan para evitar crear variables que no se usan y hay varias opciones. Aqui unos ejemplos:

``` default
// ❌ Malo, asignación de variable inútil
const [ignore, keep] = ['ignore', 'keep']; // La variable "ignore" no se utiliza

// ✅ Bueno, espacio en blanco
const [, keep] = ['ignore', 'keep']; // Se ignora el primer valor

// ✅ Bueno, guion bajo
const [_ignore, keep] = ['ignore', 'keep']; // Se ignora el primer valor y se indica con "_"

``` 


Referencias

<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring>

<https://www.w3schools.com/js/js_destructuring.asp>

<https://dmitripavlutin.com/javascript-object-destructuring/>

<https://www.samanthaming.com/tidbits/13-skip-values-in-destructuring/>

## ¿Qué hace el operador de extensión en JS?

![JS ternary](images/js_ternary.png)

El operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if...else.

``` default
condicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso
```

Por ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).

Primero veamos como seria usando condicional tipo **if ... else** :

``` default

if (lecheLitros >= 5) {
  console.log(`No comprar leche!`);
} else {
  console.log(`Comprar leche!`);
}
```

Ahora veamos un seudo código de operación ternaria:

``` default
HayMenosQueUmbral ? ComprarLeche : NoComprarLeche
```

En código seria algo como:

``` default
const umbral = 5;
let lecheLitros = 26;
const comprarLeche = lecheLitros >= umbral ? "No comprar leche" : "Comprar Leche";
console.log(comprarLeche); // "No comprar leche"
```

Como vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.

Referencias

<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator>

<https://www.w3schools.com/java/java_conditions_shorthand.asp>

<https://www.tpointtech.com/ternary-operator-in-java>

## ¿Cuál es la diferencia entre una declaración de función y una expresión de función?

En JS, se pueden definir funciones de usando declaración de función y expresión de función. Vamos a ver ejemplos y diferencias.

### Declaración de función

La función se define usando la palabra clave **function**. Se le asigna un nombre y se pueden llamar y reusar en varios sitios.

Por ejemplo, creamos una función que suma dos números de la siguiente manera:

``` default

function sumarNumeros(num1,num2){
 return num1 + num2;
}
```

***Hoisting***. Las declaraciones de funciones se elevan al inicio del contexto lo que permite llamar a la función antes de escribir la declaración en el código.

``` default

sumarNumeros(1,3);// 4

function sumarNumeros(num1,num2){
 return num1 + num2;
}
```

### Expresión de función

En este caso, a una variable se le asigna la función que puede ser anónima o tener un nombre interno. Por ejemplo, en la siguiente expresión creamos la variable getRectArea que contiene una función anónima:

``` default

const getRectArea = function(width, height) {
  return width * height;
};

console.log(getRectArea(3, 4));
// Expected output: 12
```

Un ejemplo de función con nombre podria ser:

``` default

let funcionConNombre = function miFuncion() {
    console.log("Esta es una function expression con nombre.");
};

funcionConNombre();  //
// Expected output: Esta es una function expression con nombre
```

***No hosting***. Lo que quiere decir que no se eleva y se tiene usar después de la asignación.

Un uso común de expresiones de función es cuando se requiere una función como valor como cuando se usan callbacks.

***Callbacks*** son funciones que se pasan como argumento a otra función y se ejecuta después de que ocurra un evento o se completa un proceso. Este tipo de mecánismos se usa en operaciones asíncronas como manejar eventos o esperar a una respuesta de API, ya que permite que el código continua su ejecución sin bloquearse. Por ejemplo, en en sieguiente código se espera a que ocurra un evento (click) y cuando esto ocurre, se imprime en consola un mensaje:

``` default

button.addEventListener("click", function (event) {
  console.log("button is clicked!");
});
```

Es importante observar que la secuencia de ejecución con callbacks no es la secuencia en la que estan definidas pero más bien en la secuencia en la que son llamadas.Esto permite ir llamando a funciones de manera muy dinámicas y en respuesta a las acciones de lo que podría ser las necesidades de un usuario en una web app.

Referencias

<https://www.w3schools.com/js/js_function_definition.asp>

<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function>

<https://www.w3schools.com/js/js_callback.asp>

<https://www.youtube.com/watch?v=kz_vwAF4NHI>

## ¿Qué es la programación orientada a objetos?

![JS this](images/js_this.png)

***This*** es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra "this" se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a ***this***.

Vamos a ver algunos ejemplos para entender mejor como usar ***this***:

1.  Al llamar fuera de función, se refire al objeto de ventana global.

``` default

console.log('this alone', this); // [object Window]
```

2.  Al llamar dentro de un objeto, nos referimos al objeto.

``` default

const person = {
    firstName: "John",
    lastName : "Doe",
    id       : 5566,
    getThis : function() {
      return this;
    }
};

console.log('this in object method', person.getThis());
```

Y de la misma manera, podemos usar ***this*** para llamar a otras propiedades del objeto

``` default
const person = {
    firstName: "John",
    lastName : "Doe",
    id       : 5566,
    getFullName : function() {
      return this.name + ' ' + this.lastName;
    }
};

console.log('this in object method', person.getFullName());
```

Hay otras posibles referencias de "this" que se resumen aqui:

-   En un método de un objeto, this se refiere al objeto.
-   Por sí solo, this se refiere al objeto global.
-   En una función, this se refiere al objeto global.
-   En una función en modo estricto, this es undefined.
-   En un evento, this se refiere al elemento que recibió el evento.
-   Métodos como call(), apply() y bind() pueden asignar this a cualquier objeto.

Referencias

<https://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/>

<https://keepcoding.io/blog/que-es-this-en-javascript/>

<https://www.w3schools.com/js/js_this.asp>

[https://medium.com/\@leoanimesh/javascript-this-keyword-explained-a62f3676fca1](https://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1){.uri}

## ¿Qué es una promesa en JS?

## ¿Qué hacen async y await por nosotros?

## Ejercicios

### Ejercicio 1

Crea un bucle for en JS que imprima cada nombre en esta lista.

```         
  miLista = “velma”, “exploradora”, “jane”, “john”, “harry”
```

Crea un bucle while que recorra la misma lista y también imprima los nombres. Nota: Recuerda crear un contador para que el ciclo no sea infinito.

```{ojs}
// ejercicio.js

/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes
Si el número creado es mayor que 50, la consola registra "¡El número es mayor que 50!". 
Si es más pequeño, la consola registra "¡El número es menor que 50!"
*/
function myFunctionSumaMultiplica(num1, num2,num3,num4) {
    
// Verificar que se hayan pasado exactamente 4 argumentos
if (arguments.length !== 4) {
    console.log("Error de cantidad: se deben pasar 4 argumentos.");
    return;
}

// Verificar que todos sean números
if (
    typeof num1 !== 'number' ||
    typeof num2 !== 'number' ||
    typeof num3 !== 'number' ||
    typeof num4 !== 'number'
) {
    console.log("Error de tipo: todos los 4 argumentos deben ser números.");
    return;
}
    
    let suma1 = num1 + num2;
    let suma2 = num3 + num4;
    let producto = suma1 * suma2;
    if (producto > 50) {
        console.log(`¡El número ${producto} es mayor que 50!`);
    }
    else if (producto === 50) {
        console.log(`¡El número ${producto} es igual a 50!`);
    }
    else {
        console.log(`¡El número ${producto} es menor que 50!`);
    }

    
  }

//llama a la funcion y muestra el resultado en consola
//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);

// ejemplo con error de tipo
//var resultado2 = myFunctionSumaMultiplica(2.5, 3, "4", 2);
// ejemplo con error de cantidad de argumentos
//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);



```

[Enlace a fichero JS](https://github.com/inti-documentation/inti-documentation.github.io/blob/main/checkpoint8_ejercicio1.js)

### Ejercicio 2

Cree una función de flecha que devuelva "Hola mundo".

[Enlace a fichero JS](https://github.com/inti-documentation/inti-documentation.github.io/blob/main/checkpoint8_ejercicio2.js)
