[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "inti-documentation.github.io",
    "section": "",
    "text": "Este es la documentación desarrollada para facilitar el camino para un desarrollador Fullstack Web Developer.\nThis is a Quarto website.To learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Mi nombre es Inti Luna y soy ingeniero ambiental con un gran interés en aprender a crear soluciones que integran análisis de datos y web apps.\nLinkedin\nContacto: inti.luna.aviles@gmail.com"
  },
  {
    "objectID": "index.html#qué-es-la-palabra-clave-this-en-js",
    "href": "index.html#qué-es-la-palabra-clave-this-en-js",
    "title": "inti-documentation.github.io",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "checkpoint7.html",
    "href": "checkpoint7.html",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS icon\n\n\nJavascript se diferencia de otros lenguajes (como Java, Python, C, Ruby, etc.) en que es el único que puede ser interpretado por un web browser.\nLa razón de esto es historica, en 1995 fue cuando creado por la empresa Netscape que era predominante en el mercado queria un lenguaje que pareciera como Java. Aunque inicialmente se penso para manejar Front-End y Back-End, solo ha sido exitosa en el Front-End. Aun después de la desaparición del browser de Netscape, las compañias siguientes han continuado el uso de Javascript.\nReferencias\nhttps://snipcart.com/blog/why-javascript-benefits\nhttps://en.wikipedia.org/wiki/Netscape\n\n\n\nEn JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp\n\n\n\n\nEn JS, los objeto de clase string representan texto y existen diferentes métodos que se resumen en la siguiente imagen.\n\n\n\nJS String methods\n\n\nDentro de estos metodos encontramos funcionalidades que nos permiten manipular strings que son muy utiles en la gestión de datos.\nComo ejemplo de lo múltiples metodos, vamos a asumir que hemos obtenido un texto en mínuscula pero necesitamos hacer la primera letra del titulo en mayúscula:\nlet titulo = \"hola pequeños gatos\";\n\nlet tituloCapitalizado = titulo.charAt(0).toUpperCase() + titulo.slice(1);\n\nconsole.log(tituloCapitalizado);\nAhora imaginamos que queremos hacer un split de texto, extraer el segundo objeto y removemos espacios en blanco usando trim().\n\nlet texto = \"manzana, naranja, banana\";\n\n// Dividir el texto en un array usando la coma (\",\") como separador\nlet partes = texto.split(\",\");\n\nlet segundoObjeto = partes[1].trim();\nReferencias\nhttps://www.w3schools.com/jsref/jsref_obj_string.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\n\n\n\nEn JS, una operación condicional, como el nombre indica, permite tener diferentes caminos a tomar (bloques de código a ejecutar) en dependencia de si una condición o condiciones se cumplen.\nEsto se puede entender con un ejemplo cotidiano. Digamos que vamos caminando al trabajo de manera regular pero si es tarde tenemos que tomar el metro.\n\n\n\nEjemplo condicional básico\n\n\nComo vemos, el concepto de condicional es fácil de entender y lo usamos en nuestra vida cotidiana.\nAhora en JS, la sintaxis seria:\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  console.log(`Vamos en Metro que es tarde!`);\n}\nAhora complicamos un poco más la lógica para mostrar el caso de una condicional dentro de una condicional. Por ejemplo, si fuera tarde tomamos el metro pero si es muy tarde vamos a tomar un taxi.\n\n\n\nEjemplo condicional anidado\n\n\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  if (tiempoParaTrabajar &gt; limiteMetro){\n    console.log(`Vamos en Metro que es tarde!`);\n  } else {\n    console.log(`Vamos en Taxi que es muy tarde!`);\n  }\n}\nEn caso de que hubieran multiplies condiciones a probar usamos sintaxis: “if…else if…else”.\nif (condition1)\n  statement1\nelse if (condition2)\n  statement2\nelse if (condition3)\n  statement3\n// …\nelse\n  statementN\nVeamos un ejemplo donde dependencia de la edad pagamos un precio diferente en el cine\n\nlet edad = 15;         \nlet precioBase = 10;   \nlet precioFinal;       \n\n// Aplicar descuento por edad\nif (edad &lt; 12) {\n  \n  precioFinal = precioBase * 0.5;\n} else if (edad &gt;= 12 && edad &lt; 18) {\n \n  precioFinal = precioBase * 0.75;\n} else if (edad &gt;= 65) {\n  \n  precioFinal = precioBase * 0.7;\n} else {\n \n  precioFinal = precioBase;\n}\n\n//console.log(\"El precio de la entrada es: $\" + precioFinal);\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\nhttps://www.w3schools.com/js/js_if_else.asp\n\n\n\n\n\n\nJS ternary\n\n\nEl operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if…else.\ncondicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso\nPor ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).\nPrimero veamos como seria usando condicional tipo if … else :\n\nif (lecheLitros &gt;= 5) {\n  console.log(`No comprar leche!`);\n} else {\n  console.log(`Comprar leche!`);\n}\nAhora veamos un seudo código de operación ternaria:\nHayMenosQueUmbral ? ComprarLeche : NoComprarLeche\nEn código seria algo como:\nconst umbral = 5;\nlet lecheLitros = 26;\nconst comprarLeche = lecheLitros &gt;= umbral ? \"No comprar leche\" : \"Comprar Leche\";\nconsole.log(comprarLeche); // \"No comprar leche\"\nComo vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator\nhttps://www.w3schools.com/java/java_conditions_shorthand.asp\nhttps://www.tpointtech.com/ternary-operator-in-java\n\n\n\nEn JS, se pueden definir funciones de usando declaración de función y expresión de función. Vamos a ver ejemplos y diferencias.\n\n\nLa función se define usando la palabra clave function. Se le asigna un nombre y se pueden llamar y reusar en varios sitios.\nPor ejemplo, creamos una función que suma dos números de la siguiente manera:\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\nHoisting. Las declaraciones de funciones se elevan al inicio del contexto lo que permite llamar a la función antes de escribir la declaración en el código.\n\nsumarNumeros(1,3);// 4\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\n\n\n\nEn este caso, a una variable se le asigna la función que puede ser anónima o tener un nombre interno. Por ejemplo, en la siguiente expresión creamos la variable getRectArea que contiene una función anónima:\n\nconst getRectArea = function(width, height) {\n  return width * height;\n};\n\nconsole.log(getRectArea(3, 4));\n// Expected output: 12\nUn ejemplo de función con nombre podria ser:\n\nlet funcionConNombre = function miFuncion() {\n    console.log(\"Esta es una function expression con nombre.\");\n};\n\nfuncionConNombre();  //\n// Expected output: Esta es una function expression con nombre\nNo hosting. Lo que quiere decir que no se eleva y se tiene usar después de la asignación.\nUn uso común de expresiones de función es cuando se requiere una función como valor como cuando se usan callbacks.\nCallbacks son funciones que se pasan como argumento a otra función y se ejecuta después de que ocurra un evento o se completa un proceso. Este tipo de mecánismos se usa en operaciones asíncronas como manejar eventos o esperar a una respuesta de API, ya que permite que el código continua su ejecución sin bloquearse. Por ejemplo, en en sieguiente código se espera a que ocurra un evento (click) y cuando esto ocurre, se imprime en consola un mensaje:\n\nbutton.addEventListener(\"click\", function (event) {\n  console.log(\"button is clicked!\");\n});\nEs importante observar que la secuencia de ejecución con callbacks no es la secuencia en la que estan definidas pero más bien en la secuencia en la que son llamadas.Esto permite ir llamando a funciones de manera muy dinámicas y en respuesta a las acciones de lo que podría ser las necesidades de un usuario en una web app.\nReferencias\nhttps://www.w3schools.com/js/js_function_definition.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\nhttps://www.w3schools.com/js/js_callback.asp\nhttps://www.youtube.com/watch?v=kz_vwAF4NHI\n\n\n\n\n\n\n\nJS this\n\n\nThis es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra “this” se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a this.\nVamos a ver algunos ejemplos para entender mejor como usar this:\n\nAl llamar fuera de función, se refire al objeto de ventana global.\n\n\nconsole.log('this alone', this); // [object Window]\n\nAl llamar dentro de un objeto, nos referimos al objeto.\n\n\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getThis : function() {\n      return this;\n    }\n};\n\nconsole.log('this in object method', person.getThis());\nY de la misma manera, podemos usar this para llamar a otras propiedades del objeto\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getFullName : function() {\n      return this.name + ' ' + this.lastName;\n    }\n};\n\nconsole.log('this in object method', person.getFullName());\nHay otras posibles referencias de “this” que se resumen aqui:\n\nEn un método de un objeto, this se refiere al objeto.\nPor sí solo, this se refiere al objeto global.\nEn una función, this se refiere al objeto global.\nEn una función en modo estricto, this es undefined.\nEn un evento, this se refiere al elemento que recibió el evento.\nMétodos como call(), apply() y bind() pueden asignar this a cualquier objeto.\n\nReferencias\nhttps://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.w3schools.com/js/js_this.asp\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1\n\n\n\n\n// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS"
  },
  {
    "objectID": "checkpoint7.html#qué-es-la-palabra-clave-this-en-js",
    "href": "checkpoint7.html#qué-es-la-palabra-clave-this-en-js",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS this\n\n\nThis es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra “this” se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a this.\nVamos a ver algunos ejemplos para entender mejor como usar this:\n\nAl llamar fuera de función, se refire al objeto de ventana global.\n\n\nconsole.log('this alone', this); // [object Window]\n\nAl llamar dentro de un objeto, nos referimos al objeto.\n\n\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getThis : function() {\n      return this;\n    }\n};\n\nconsole.log('this in object method', person.getThis());\nY de la misma manera, podemos usar this para llamar a otras propiedades del objeto\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getFullName : function() {\n      return this.name + ' ' + this.lastName;\n    }\n};\n\nconsole.log('this in object method', person.getFullName());\nHay otras posibles referencias de “this” que se resumen aqui:\n\nEn un método de un objeto, this se refiere al objeto.\nPor sí solo, this se refiere al objeto global.\nEn una función, this se refiere al objeto global.\nEn una función en modo estricto, this es undefined.\nEn un evento, this se refiere al elemento que recibió el evento.\nMétodos como call(), apply() y bind() pueden asignar this a cualquier objeto.\n\nReferencias\nhttps://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.w3schools.com/js/js_this.asp\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1"
  },
  {
    "objectID": "checkpoint7.html#ejercicio",
    "href": "checkpoint7.html#ejercicio",
    "title": "JS - CKP7",
    "section": "",
    "text": "// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS"
  },
  {
    "objectID": "checkpoint7.html#qué-diferencia-a-javascript-de-cualquier-otro-lenguaje-de-programación",
    "href": "checkpoint7.html#qué-diferencia-a-javascript-de-cualquier-otro-lenguaje-de-programación",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS icon\n\n\nJavascript se diferencia de otros lenguajes (como Java, Python, C, Ruby, etc.) en que es el único que puede ser interpretado por un web browser.\nLa razón de esto es historica, en 1995 fue cuando creado por la empresa Netscape que era predominante en el mercado queria un lenguaje que pareciera como Java. Aunque inicialmente se penso para manejar Front-End y Back-End, solo ha sido exitosa en el Front-End. Aun después de la desaparición del browser de Netscape, las compañias siguientes han continuado el uso de Javascript.\nReferencias\nhttps://snipcart.com/blog/why-javascript-benefits\nhttps://en.wikipedia.org/wiki/Netscape"
  },
  {
    "objectID": "checkpoint7.html#cuáles-son-algunos-tipos-de-datos-js",
    "href": "checkpoint7.html#cuáles-son-algunos-tipos-de-datos-js",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp"
  },
  {
    "objectID": "checkpoint7.html#qué-es-un-operador-ternario",
    "href": "checkpoint7.html#qué-es-un-operador-ternario",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS ternary\n\n\nEl operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if…else.\ncondicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso\nPor ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).\nPrimero veamos como seria usando condicional tipo if … else :\n\nif (lecheLitros &gt;= 5) {\n  console.log(`No comprar leche!`);\n} else {\n  console.log(`Comprar leche!`);\n}\nAhora veamos un seudo código de operación ternaria:\nHayMenosQueUmbral ? ComprarLeche : NoComprarLeche\nEn código seria algo como:\nconst umbral = 5;\nlet lecheLitros = 26;\nconst comprarLeche = lecheLitros &gt;= umbral ? \"No comprar leche\" : \"Comprar Leche\";\nconsole.log(comprarLeche); // \"No comprar leche\"\nComo vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator\nhttps://www.w3schools.com/java/java_conditions_shorthand.asp\nhttps://www.tpointtech.com/ternary-operator-in-java"
  },
  {
    "objectID": "checkpoint7.html#qué-es-un-condicional",
    "href": "checkpoint7.html#qué-es-un-condicional",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JS, una operación condicional, como el nombre indica, permite tener diferentes caminos a tomar (bloques de código a ejecutar) en dependencia de si una condición o condiciones se cumplen.\nEsto se puede entender con un ejemplo cotidiano. Digamos que vamos caminando al trabajo de manera regular pero si es tarde tenemos que tomar el metro.\n\n\n\nEjemplo condicional básico\n\n\nComo vemos, el concepto de condicional es fácil de entender y lo usamos en nuestra vida cotidiana.\nAhora en JS, la sintaxis seria:\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  console.log(`Vamos en Metro que es tarde!`);\n}\nAhora complicamos un poco más la lógica para mostrar el caso de una condicional dentro de una condicional. Por ejemplo, si fuera tarde tomamos el metro pero si es muy tarde vamos a tomar un taxi.\n\n\n\nEjemplo condicional anidado\n\n\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  if (tiempoParaTrabajar &gt; limiteMetro){\n    console.log(`Vamos en Metro que es tarde!`);\n  } else {\n    console.log(`Vamos en Taxi que es muy tarde!`);\n  }\n}\nEn caso de que hubieran multiplies condiciones a probar usamos sintaxis: “if…else if…else”.\nif (condition1)\n  statement1\nelse if (condition2)\n  statement2\nelse if (condition3)\n  statement3\n// …\nelse\n  statementN\nVeamos un ejemplo donde dependencia de la edad pagamos un precio diferente en el cine\n\nlet edad = 15;         \nlet precioBase = 10;   \nlet precioFinal;       \n\n// Aplicar descuento por edad\nif (edad &lt; 12) {\n  \n  precioFinal = precioBase * 0.5;\n} else if (edad &gt;= 12 && edad &lt; 18) {\n \n  precioFinal = precioBase * 0.75;\n} else if (edad &gt;= 65) {\n  \n  precioFinal = precioBase * 0.7;\n} else {\n \n  precioFinal = precioBase;\n}\n\n//console.log(\"El precio de la entrada es: $\" + precioFinal);\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\nhttps://www.w3schools.com/js/js_if_else.asp"
  },
  {
    "objectID": "checkpoint7.html#cuál-es-la-diferencia-entre-una-declaración-de-función-y-una-expresión-de-función",
    "href": "checkpoint7.html#cuál-es-la-diferencia-entre-una-declaración-de-función-y-una-expresión-de-función",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JS, se pueden definir funciones de usando declaración de función y expresión de función. Vamos a ver ejemplos y diferencias.\n\n\nLa función se define usando la palabra clave function. Se le asigna un nombre y se pueden llamar y reusar en varios sitios.\nPor ejemplo, creamos una función que suma dos números de la siguiente manera:\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\nHoisting. Las declaraciones de funciones se elevan al inicio del contexto lo que permite llamar a la función antes de escribir la declaración en el código.\n\nsumarNumeros(1,3);// 4\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\n\n\n\nEn este caso, a una variable se le asigna la función que puede ser anónima o tener un nombre interno. Por ejemplo, en la siguiente expresión creamos la variable getRectArea que contiene una función anónima:\n\nconst getRectArea = function(width, height) {\n  return width * height;\n};\n\nconsole.log(getRectArea(3, 4));\n// Expected output: 12\nUn ejemplo de función con nombre podria ser:\n\nlet funcionConNombre = function miFuncion() {\n    console.log(\"Esta es una function expression con nombre.\");\n};\n\nfuncionConNombre();  //\n// Expected output: Esta es una function expression con nombre\nNo hosting. Lo que quiere decir que no se eleva y se tiene usar después de la asignación.\nUn uso común de expresiones de función es cuando se requiere una función como valor como cuando se usan callbacks.\nCallbacks son funciones que se pasan como argumento a otra función y se ejecuta después de que ocurra un evento o se completa un proceso. Este tipo de mecánismos se usa en operaciones asíncronas como manejar eventos o esperar a una respuesta de API, ya que permite que el código continua su ejecución sin bloquearse. Por ejemplo, en en sieguiente código se espera a que ocurra un evento (click) y cuando esto ocurre, se imprime en consola un mensaje:\n\nbutton.addEventListener(\"click\", function (event) {\n  console.log(\"button is clicked!\");\n});\nEs importante observar que la secuencia de ejecución con callbacks no es la secuencia en la que estan definidas pero más bien en la secuencia en la que son llamadas.Esto permite ir llamando a funciones de manera muy dinámicas y en respuesta a las acciones de lo que podría ser las necesidades de un usuario en una web app.\nReferencias\nhttps://www.w3schools.com/js/js_function_definition.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\nhttps://www.w3schools.com/js/js_callback.asp\nhttps://www.youtube.com/watch?v=kz_vwAF4NHI"
  },
  {
    "objectID": "checkpoint7.html#cuáles-son-las-tres-funciones-de-string-en-js",
    "href": "checkpoint7.html#cuáles-son-las-tres-funciones-de-string-en-js",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JS, los objeto de clase string representan texto y existen diferentes métodos que se resumen en la siguiente imagen.\n\n\n\nJS String methods\n\n\nDentro de estos metodos encontramos funcionalidades que nos permiten manipular strings que son muy utiles en la gestión de datos.\nComo ejemplo de lo múltiples metodos, vamos a asumir que hemos obtenido un texto en mínuscula pero necesitamos hacer la primera letra del titulo en mayúscula:\nlet titulo = \"hola pequeños gatos\";\n\nlet tituloCapitalizado = titulo.charAt(0).toUpperCase() + titulo.slice(1);\n\nconsole.log(tituloCapitalizado);\nAhora imaginamos que queremos hacer un split de texto, extraer el segundo objeto y removemos espacios en blanco usando trim().\n\nlet texto = \"manzana, naranja, banana\";\n\n// Dividir el texto en un array usando la coma (\",\") como separador\nlet partes = texto.split(\",\");\n\nlet segundoObjeto = partes[1].trim();\nReferencias\nhttps://www.w3schools.com/jsref/jsref_obj_string.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"
  },
  {
    "objectID": "js_checkpoint8.html",
    "href": "js_checkpoint8.html",
    "title": "JS - CKP8",
    "section": "",
    "text": "JS icon\n\n\n\n\n\n\n\nTomado de https://www.linkedin.com/pulse/loop-while-dowhile-javascript-hadi-soufan/\n\n\nLos bucles son una manera de repetir un proceso. Los bucles más comunes son:\n\nFor: itera sobre una secuencia de elementos, como un array o un objeto.\nWhile: repite proceso mientras se cumple una condición.Si no se cumple, no se corre el proceso ninguna vez.\nDo-While: similar al bucle While, pero se ejecuta al menos una vez antes de evaluar la condición.\n\nVeamos ahora detalle de cada tipo de bucle y ejemplos de cada uno.\n\nBucle For\n\nEl bucle for es el más común y se utiliza para ejecutar un bloque de código un número determinado de veces. La sintaxis básica es:\nfor (inicialización; condición; incremento) {\n  // código a ejecutar\n}\nDonde:\ninicialización: es la expresión que se ejecuta antes de comenzar el bucle. condición: es la expresión que se evalúa en cada iteración para determinar si el bucle debe continuar. incremento: es la expresión que se ejecuta al final de cada iteración para actualizar la variable de control.\nEjemplo:\nfor (let i = 0; i &lt; 5; i++) {\n  console.log(i);\n}\n// Salida: 0, 1, 2, 3, 4\n\nBucle While\n\nEl bucle while se utiliza para ejecutar un bloque de código mientras se cumple una condición determinada. La sintaxis básica es:\nwhile (condición) {\n  // código a ejecutar\n}\nDonde condición es la expresión que se evalúa en cada iteración para determinar si el bucle debe continuar.\nEjemplo:\nlet i = 0;\nwhile (i &lt; 5) {\n  console.log(i);\n  i++;\n}\n// Salida: 0, 1, 2, 3, 4\n\nBucle Do-While\n\nEl bucle do-while es similar al bucle while, pero se ejecuta al menos una vez antes de evaluar la condición. La sintaxis básica es:\ndo {\n  // código a ejecutar\n} while (condición);\nDonde condición es la expresión que se evalúa en cada iteración para determinar si el bucle debe continuar.\nEl bucle Do-While se ejecuta de la siguiente manera:\n\nSe ejecuta el código dentro del bloque do al menos una vez.\nLuego, se evalúa la condición en la cláusula while.\nSi la condición es true, se vuelve a ejecutar el código dentro del bloque do.\nSi la condición es false, el bucle termina.\n\nEjemplo:\nlet i = 0;\ndo {\n  console.log(i);\n  i++;\n} while (i &lt; 5);\n// Salida: 0, 1, 2, 3, 4\nEn este ejemplo, el bucle Do-While se ejecuta al menos una vez, imprimiendo el valor de i (0). Luego, se evalúa la condición i &lt; 5, que es true, por lo que se vuelve a ejecutar el código dentro del bloque do, imprimiendo el valor de i (1). Esto continúa hasta que i sea 5, momento en el que la condición es false y el bucle termina.\nLa principal diferencia entre While y Do-While es que Do-While se ejecuta al menos una vez, mientras que While puede no ejecutarse nunca si la condición inicial es false.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration\nhttps://www.w3schools.com/jsref/jsref_dowhile.asp\nhttps://www.linkedin.com/pulse/loop-while-dowhile-javascript-hadi-soufan/\n\n\n\nEn JavaScript, const, let y var se utilizan para declarar variables, pero tienen diferencias clave en su alcance y comportamiento (hoisting, reglas de reasignación):\nHoisting: Es un comportamiento donde las declaraciones de variables se mueven a la parte superior del ambito en el que se declaran.\nvar: La variable declarada con var tiene un alcance de función o global, es decir, se aplica a toda la función en la que se declara. Puede ser redeclarada y reasignada.\nvar persona = { nombre: \"Ana\", edad: 28 };\n\nvar persona = { nombre: \"Fran\", edad: 25 };\nEjemplo de Hoisting para var donde se tiene:\n\nconsole.log(x); // undefined\nvar x = 10;\nDebido al hoisting, el código se ejecuta como si fuera la variable declarada y no asignada hasta después:\nvar x;\nconsole.log(x); // undefined\nx = 10;\nlet: La variable declarada con let tiene un alcance de bloque, es decir, se aplica solo dentro del bloque en el que se declara. Puede ser reasignada, pero no redeclarada.\nEn el siguiente ejemplo se observa como si se llama a una variable declarada dentro de función y se intenta llamar fuera del bloque nos da error:\nif (true) {\n    let nombre = \"Juan\";\n    console.log(nombre);\n}\nconsole.log(nombre); // Error: nombre is not defined\nEn otro ejemplo se usa let para declarar una variable global y luego otra local (dentro de función):\nlet edad = 25;\nif (true) {\n    let edad = 30; \n    console.log(edad); // 30\n}\nconsole.log(edad); // 25\nSe observa como la variable local solo es accesible dentro del bloque if y no afecta a la variable global.\nHoisting para let funciona diferente que para var, ya que que con let no se inicializa la variable y causa un error:\nconsole.log(number)\n// ReferenceError: Cannot access 'number' before initialization\n\nlet number = 50\nconst: La variable declarada con const también tiene un alcance de bloque, pero no puede ser reasignada ni redeclarada. Su valor es constante.\nconst edad = 30; \nedad = 35; // Error: Assignment to constant variable.\nHoisting para const es similar que para let donde no se inicializa variable y da error:\nconsole.log(number)\n// ReferenceError: Cannot access 'number' before initialization\n\nconst number = 50\nDebido a que usar variables antes de declararlas puede causar problemas, algunas veces se recomienda seguir la regla no-use-before-define o lo que es definir primero y hasta después usar.\nReferencias\nhttps://www.geeksforgeeks.org/difference-between-var-let-and-const-keywords-in-javascript/\nhttps://www.freecodecamp.org/news/differences-between-var-let-const-javascript/\nhttps://eslint.org/docs/latest/rules/no-use-before-define\n\n\n\nUna función flecha es una forma concisa de definir una función en JavaScript. Se utiliza la sintaxis () =&gt; {} para crear una función anónima.\nEjemplo de una función normal (function declaration) que suma dos números:\nfunction sumar(a, b) {\n  return a + b;\n}\nLa versión con función anónima:\nvar sumar = function(a, b) {\n  return a + b;\n}\nAhora miramos versión de función flecha equivalente:\nconst sumar = (a, b) =&gt; a + b;\nconsole.log(sumar(2, 3)); // 5\nVariantes\nHay algunas variantes, por ejemplo los parentesis en los argumentos. En la función anterior usamos como argumentos (a,b) que nos regresa el resultado de expresión (a+b) pero en caso de que hubiera un solo argumento, los parentesis pueden ser omitidos. Por ejemplo en la siguiente expression la función puede ser escrita con o sin parentesis.\nlet double = n =&gt; n * 2;\n// igual que: let double = (n) =&gt; n * 2;\n// Muy similar a funcion anónima: let double = function(n) { return n * 2 }\n\nalert( double(3) ); // 6\nEn caso de que no hubiera argumentos, los parentesis tienen que estar vacios. Por ejemplo:\nlet saluda = () =&gt; alert(\"Hola\");\nsaluda();\nMultilinea.En caso de que se tenga que realizar varias expresiones dentro de la función se usa “{}” para englobar la diferentes lineas y se debe incluir “return” para que nos regrese algo, justo como en función normal. Veamos un ejemplo donde se evalua que los valores pasados a función son positivos y luego calcula el área:\nconst calcularArea = (base, altura) =&gt; {\n  if (base &lt;= 0 || altura &lt;= 0) {\n    throw new Error(\"La base y la altura deben ser números positivos\");\n  }\n  const area = base * altura;\n  return area;\n}\nCuándo usar funciones flecha\nSe recomienda usar funciones flecha en los siguientes casos:\n\nFunciones cortas y simples: Cuando la función es muy simple y no requiere una gran cantidad de código, las funciones flecha son ideales.\nCallbacks: Las funciones flecha son útiles como callbacks, ya que son más concisas y fáciles de leer.\nFunciones anónimas: Las funciones flecha son una forma natural de crear funciones anónimas.\nMap, filter, reduce: Las funciones flecha son ideales para usar con métodos de arrays como map, filter y reduce.\n\nEjemplo de uso con map:\nconst numbers = [1, 2, 3, 4, 5];\nconst doubles = numbers.map((num) =&gt; num * 2);\nconsole.log(doubles); // [2, 4, 6, 8, 10]\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\nhttps://www.w3schools.com/js/js_arrow_function.asp\nhttps://javascript.info/arrow-functions-basics\n\n\n\n\n\n\nTomado de www.samanthaming.com\n\n\nLa deconstrucción de variables es una forma de asignar valores a variables a partir de un objeto o un array.\nSe utiliza la sintaxis para objeto: { variable1, variable2, ... } = objeto\nSe utiliza la sintaxis para array: [variable1, variable2, ...] = array.\nLa deconstrucción de variables es útil para simplificar el código y evitar la necesidad de acceder a las propiedades de un objeto o los elementos de un array mediante su índice o nombre.\nVeamos como funciona con algunos ejemplos:\n// Deconstrucción de objeto\nconst persona = { nombre: \"Juan\", edad: 30 };\nconst { nombre, edad } = persona;\n\nconsole.log(nombre); // Output: \"Juan\"\nconsole.log(edad); // Output: 30\nY para un array tenemos:\n// Deconstrucción de array\nconst frutas = [\"manzana\", \"banana\", \"naranja\"];\nconst [fruta1, fruta2, fruta3] = frutas;\n\nconsole.log(fruta1); // Output: \"manzana\"\nconsole.log(fruta2); // Output: \"banana\"\nconsole.log(fruta3); // Output: \"naranja\"\nValores predeterminados\nA una variable se le puede asignar un valor predeterminado, en el caso de que el valor desempacado del arreglo sea undefined.\nVeamos un ejemplo para objeto donde se desestructura el objeto persona y se asignan valores predeterminados a las variables nombre, edad y pais. Si el objeto persona no tiene una propiedad con el nombre correspondiente, se asigna el valor predeterminado.\nconst persona = { nombre: \"Juan\", edad: 30 };\nconst { nombre = \"Desconocido\", edad = 0, pais = \"No especificado\" } = persona;\n\nconsole.log(nombre); // \"Juan\"\nconsole.log(edad);   // 30\nconsole.log(pais);   // \"No especificado\"\nAhora veamos un ejemplo usando array donde se desestructura el array colores y se asignan valores predeterminados a las variables primero, segundo y tercero. Si el array colores no tiene suficientes elementos, se asignan los valores predeterminados a las variables restantes.\nconst colores = [\"rojo\", \"azul\"];\nconst [primero = \"negro\", segundo = \"blanco\", tercero = \"gris\"] = colores;\n\nconsole.log(primero); // \"rojo\"\nconsole.log(segundo); // \"azul\"\nconsole.log(tercero); // \"gris\"\nIgnorar valores devueltos\nSe puede ignorar los valores que no interesan para evitar crear variables que no se usan y hay varias opciones. Aqui unos ejemplos:\n// ❌ Malo, asignación de variable inútil\nconst [ignore, keep] = ['ignore', 'keep']; // La variable \"ignore\" no se utiliza\n\n// ✅ Bueno, espacio en blanco\nconst [, keep] = ['ignore', 'keep']; // Se ignora el primer valor\n\n// ✅ Bueno, guion bajo\nconst [_ignore, keep] = ['ignore', 'keep']; // Se ignora el primer valor y se indica con \"_\"\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring\nhttps://www.w3schools.com/js/js_destructuring.asp\nhttps://dmitripavlutin.com/javascript-object-destructuring/\nhttps://www.samanthaming.com/tidbits/13-skip-values-in-destructuring/\n\n\n\nEl operador de extensión o spread syntax(...) se utiliza para expandir un array o un objeto en una nueva estructura de datos. La sintaxis extendida permite a un elemento iterable tal como un arreglo o cadena ser expandido en lugares donde cero o más argumentos (para llamadas de función) o elementos (para Array literales) son esperados, o a un objeto ser expandido en lugares donde cero o más pares de valores clave (para literales Tipo Objeto) son esperados.\n// Expansión de array\nconst numeros = [1, 2, 3];\nconst nuevosNumeros = [...numeros, 4, 5, 6];\n\nconsole.log(nuevosNumeros); // Output: [1, 2, 3, 4, 5, 6]\n\n// Expansión de objeto\nconst persona = { nombre: \"Juan\", edad: 30 };\nconst nuevaPersona = { ...persona, direccion: \"Calle 123\" };\n\nconsole.log(nuevaPersona); // Output: { nombre: \"Juan\", edad: 30, direccion: \"Calle 123\" }\nEl operador de extensión es útil para crear copias de arrays y objetos, y para combinar datos de diferentes fuentes.\nCrear copias\nEn el contexto de crear copias, se utiliza para crear una copia superficial de un array o un objeto.\n\nCopiar arrays\n\nPara copiar un array, puedes utilizar el operador de propagación de la siguiente manera:\nconst original = [1, 2, 3];\nconst copia = [...original];\n\nconsole.log(copia); // [1, 2, 3]\nEn este ejemplo, se crea una copia del array original utilizando el operador de propagación (…). La copia se almacena en la variable copia.\n\nCopiar objetos\n\nDe manera similar, puedes copiar un objeto utilizando el operador de propagación:\nconst original = { a: 1, b: 2 };\nconst copia = { ...original };\n\nconsole.log(copia); // { a: 1, b: 2 }\nSi te preguntas que es una copia superficial aqui se explica. La copia creada con el operador de propagación se llama “copia superficial” (o “shallow copy” en inglés) porque solo copia los valores de las propiedades del objeto o los elementos del array de manera directa, sin copiar los objetos o arrays anidados.\nEn otras palabras, si el objeto o array original contiene referencias a otros objetos o arrays, la copia solo copiará las referencias, no los objetos o arrays en sí mismos. Esto significa que si se modifica el objeto o array original, la copia también se verá afectada, ya que ambos comparten las mismas referencias.\nAquí hay un ejemplo:\n\nconst original = {\n  a: 1,\n  b: [2, 3],\n  c: { d: 4 }\n};\n\nconst copia = { ...original };\n\ncopia.b.push(5);\ncopia.c.d = 6;\n\nconsole.log(original); // { a: 1, b: [2, 3, 5], c: { d: 6 } }\nconsole.log(copia); // { a: 1, b: [2, 3, 5], c: { d: 6 } }\nEn este ejemplo, el objeto original se ve afectada por las modificaciones realizadas en el objeto copia, ya que ambos comparten las mismas referencias a los arrays y objetos anidados.\nPara crear una copia profunda (o “deep copy”) que no comparta referencias con el objeto original, se necesitan técnicas más avanzadas, como la recursividad o la utilización de bibliotecas como Lodash\nCombinar datos\nEl operador de propagación (spread syntax) también se puede utilizar para combinar datos de diferentes fuentes en un nuevo array o objeto.\n\nCombinar arrays\n\nPara combinar dos o más arrays, puedes utilizar el operador de propagación de la siguiente manera:\nconst array1 = [1, 2, 3];\nconst array2 = [4, 5, 6];\n\nconst combinado = [...array1, ...array2];\n\nconsole.log(combinado); // [1, 2, 3, 4, 5, 6]\nEn este ejemplo, se combinan los arrays array1 y array2 en un nuevo array llamado combinado.\n\nCombinar objetos\n\nDe manera similar, puedes combinar dos o más objetos utilizando el operador de propagación:\nconst objeto1 = { a: 1, b: 2 };\nconst objeto2 = { c: 3, d: 4 };\n\nconst combinado = {...objeto1, ...objeto2};\n\nconsole.log(combinado); // { a: 1, b: 2, c: 3, d: 4 }\nEn este ejemplo, se combinan los objetos objeto1 y objeto2 en un nuevo objeto llamado combinado.\nCombinar arrays y objetos.También puedes combinar arrays y objetos utilizando el operador de propagación:\nconst array = [1, 2, 3];\nconst objeto = { a: 4, b: 5 };\n\nconst combinado = [...array, objeto];\n\nconsole.log(combinado); // [1, 2, 3, { a: 4, b: 5 }]\nEn este ejemplo, se combina el array array con el objeto objeto en un nuevo array llamado combinado.\nSobrescritura de propiedades\nCuando se combinan objetos utilizando el operador de propagación, si dos o más objetos tienen propiedades con el mismo nombre, la propiedad del objeto que se combina en segundo lugar sobrescribirá la propiedad del objeto que se combina en primer lugar.\nAquí hay un ejemplo:\nconst objeto1 = { a: 1, b: 2 };\nconst objeto2 = { b: 3, c: 4 };\n\nconst combinado = {...objeto1, ...objeto2};\n\nconsole.log(combinado); // { a: 1, b: 3, c: 4 }\nEn este ejemplo, la propiedad b del objeto objeto2 sobrescribe la propiedad b del objeto objeto1, por lo que el valor de b en el objeto combinado es 3, no 2.\nEs importante tener en cuenta que esto se aplica a todas las propiedades que se combinan, no solo a las que tienen el mismo nombre. Si un objeto tiene una propiedad que no existe en el otro objeto, se agregará al objeto combinado sin problemas.\nAquí hay un ejemplo con múltiples objetos:\nconst objeto1 = { a: 1, b: 2 };\nconst objeto2 = { b: 3, c: 4 };\nconst objeto3 = { c: 5, d: 6 };\n\nconst combinado = {...objeto1, ...objeto2, ...objeto3};\n\nconsole.log(combinado); // { a: 1, b: 3, c: 5, d: 6 }\nEn este ejemplo, la propiedad b del objeto objeto2 sobrescribe la propiedad b del objeto objeto1, y la propiedad c del objeto objeto3 sobrescribe la propiedad c del objeto objeto2. El objeto combinado tiene las propiedades de todos los objetos, con las sobrescrituras correspondientes.\nEn llamadas de función\nEl operador de propagación (spread syntax) se puede utilizar en llamadas de función para pasar argumentos de manera flexible y conveniente.\nPasar argumentos como array\nEn JavaScript, cuando se llama a una función, se pueden pasar argumentos de manera individual, como en el siguiente ejemplo:\nfunction suma(a, b, c) {\n  return a + b + c;\n}\n\nconst resultado = suma(1, 2, 3);\nconsole.log(resultado); // 6\nSin embargo, si se tiene un array de valores que se desean pasar como argumentos, se puede utilizar el operador de propagación para “desempacar” el array y pasar sus elementos como argumentos individuales:\nfunction suma(a, b, c) {\n  return a + b + c;\n}\n\nconst valores = [1, 2, 3];\nconst resultado = suma(...valores);\nconsole.log(resultado); // 6\nEn este ejemplo, el operador de propagación (…) se utiliza para “desempacar” el array valores y pasar sus elementos como argumentos individuales a la función suma.\notra aplicación importante del operador de propagación en funciones: permitir que una función acepte un número variable de argumentos.\nFunciones con un número variable de argumentos\nEn JavaScript, se puede definir una función que acepte un número variable de argumentos utilizando el operador de propagación en la lista de parámetros. Esto se conoce como “rest parameter” (parámetro de resto).\nAquí hay un ejemplo:\nfunction suma(...numeros) {\n  return numeros.reduce((a, b) =&gt; a + b, 0);\n}\n\nconsole.log(suma(1, 2, 3)); // 6\nconsole.log(suma(1, 2, 3, 4, 5)); // 15\nEn este ejemplo, la función suma acepta un número variable de argumentos, que se almacenan en el array numeros. La función utiliza el método reduce para sumar todos los números en el array y devolver el resultado.\nEl operador de propagación (…) se utiliza para indicar que el parámetro numeros es un parámetro de resto, que puede aceptar cualquier número de argumentos.\nDe esta manera, la función suma puede ser llamada con cualquier número de argumentos, y siempre devolverá la suma de todos los números pasados como argumentos.\nOtro ejemplo\nAquí hay otro ejemplo de una función que utiliza el operador de propagación para aceptar un número variable de argumentos:\n\nfunction max(...numeros) {\n  return Math.max(...numeros);\n}\n\nconsole.log(max(1, 2, 3)); // 3\nconsole.log(max(1, 2, 3, 4, 5)); // 5\nEn este ejemplo, la función max acepta un número variable de argumentos y devuelve el máximo de todos los números pasados como argumentos.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\nhttps://www.w3schools.com/howto/howto_js_spread_operator.asp\nhttps://lodash.com/\nhttps://www.geeksforgeeks.org/lodash-_-clonedeep-method/\n\n\n\nLa programación orientada a objetos (POO) es un paradigma de programación que se centra en la creación de objetos que tienen propiedades y métodos que describen su comportamiento. En JavaScript, la POO se utiliza para crear objetos que pueden interactuar entre sí y con otros objetos.\nCreación de objetos en JavaScript\nEn JavaScript, los objetos se pueden crear de dos maneras:\n\nSintaxis de objeto literal.\n\nEsta es la forma más común de crear objetos en JavaScript. Se utiliza la sintaxis {} para crear un objeto y se pueden agregar propiedades y métodos utilizando la sintaxis clave: valor\n// Ejemplo de objeto en JavaScript\nconst persona = {\n  nombre: \"Ernesto\",\n  edad: 41,\n  profesion: \"ingeniero ambiental\",\n  saludar: function() {\n    console.log(`Hola, me llamo ${this.nombre}, tengo ${this.edad} años y trabajo como ${profesion}`);\n  }\n};\n\npersona.saludar(); // Output: \"Hola, me llamo Ernesto, tengo 41 años y trabajo como ingeniero ambiental\"\nEn este ejemplo, se crea un objeto persona con tres propiedades: nombre, edad, profesión y el método saludar. La propiedad saludar es un método que se puede llamar para saludar.\n\nConstructores.\n\nLos constructores son funciones especiales que se utilizan para crear objetos. Se utilizan la palabra clave new para crear un objeto a partir de un constructor.\nfunction Persona(nombre, edad, profesion) {\n  this.nombre = nombre;\n  this.edad = edad;\n  this.profesion = profesion;\n  this.saludar = function() {\n    console.log(`Hola, me llamo ${this.nombre}`);\n  };\n}\n\nconst persona = new Persona('Ines', 30, \"Doctora\");\nEn este ejemplo, se define un constructor Persona que toma tres parámetros: nombre, edad y profesión. El constructor crea un objeto con las propiedades nombre, edad, profesión y el método saludar. Luego, se crea un objeto persona utilizando el constructor Persona y la palabra clave new.\nDiferencias entre la sintaxis de objeto literal y los constructores\nLa principal diferencia entre la sintaxis de objeto literal y los constructores es la forma en que se crean los objetos. La sintaxis de objeto literal es más concisa y fácil de leer, mientras que los constructores ofrecen más flexibilidad y permiten la creación de objetos con propiedades y métodos dinámicos.\nHerencia\nLa herencia es un concepto fundamental en la Programación Orientada a Objetos (OOP) que permite crear una nueva clase a partir de una clase existente, heredando sus propiedades y métodos. En JavaScript, la herencia se puede implementar utilizando la palabra clave extends y la función constructor.\nEjemplo de herencia\nSupongamos que tenemos una clase Vehiculo que tiene propiedades como marca, modelo y año, y métodos como arrancar y detener. Queremos crear una clase Coche que herede las propiedades y métodos de Vehiculo y agregue algunas propiedades y métodos adicionales.\n// Clase Vehiculo\nclass Vehiculo {\n  constructor(marca, modelo, año) {\n    this.marca = marca;\n    this.modelo = modelo;\n    this.año = año;\n  }\n\n  arrancar() {\n    console.log(`El vehículo ${this.marca} ${this.modelo} está arrancando`);\n  }\n\n  detener() {\n    console.log(`El vehículo ${this.marca} ${this.modelo} está deteniendo`);\n  }\n}\n\n// Clase Coche que hereda de Vehiculo\nclass Coche extends Vehiculo {\n  constructor(marca, modelo, año, puertas) {\n    super(marca, modelo, año);\n    this.puertas = puertas;\n  }\n\n  abrirPuertas() {\n    console.log(`Se abren las ${this.puertas} puertas del coche ${this.marca} ${this.modelo}`);\n  }\n}\nLa clase Coche hereda de Vehiculo utilizando la palabra clave extends. El constructor de Coche llama al constructor de Vehiculo utilizando la función super, pasando los parámetros marca, modelo y año. Luego, inicializa la propiedad puertas propia de la clase Coche.\nLa función super se utiliza para llamar al constructor de la clase padre (en este caso, Vehiculo) y heredar sus propiedades y métodos. De esta manera, la clase Coche tiene acceso a las propiedades y métodos de Vehiculo, como marca, modelo, año, arrancar y detener, y puede agregar sus propias propiedades y métodos, como puertas y abrirPuertas.\nA continuación se presenta ejemplo de como usar clase Coche que hereda de vehiculo:\n// Crear un objeto de la clase Coche\nconst miCoche = new Coche('Toyota', 'Corolla', 2015, 4);\n\n// Llamar a los métodos heredados de Vehiculo\nmiCoche.arrancar(); // El vehículo Toyota Corolla está arrancando\nmiCoche.detener(); // El vehículo Toyota Corolla está deteniendo\n\n// Llamar al método propio de Coche\nmiCoche.abrirPuertas(); // Se abren las 4 puertas del coche Toyota Corolla\n\n// Acceder a las propiedades\nconsole.log(miCoche.marca); // Toyota\nconsole.log(miCoche.modelo); // Corolla\nconsole.log(miCoche.año); // 2015\nconsole.log(miCoche.puertas); // 4\nEn este ejemplo, creamos un objeto miCoche de la clase Coche, pasando los parámetros marca, modelo, año y puertas. Luego, llamamos a los métodos heredados de Vehiculo, como arrancar y detener, y al método propio de Coche, como abrirPuertas.\nReferencias\nhttps://www.w3schools.com/js/js_object_constructors.asp\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.geeksforgeeks.org/introduction-object-oriented-programming-javascript/\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1\n\n\n\nLas promesas en JavaScript son un mecanismo para manejar operaciones asíncronas, como solicitudes de red, lecturas de archivos o bases de datos, de manera más eficiente y fácil de entender. Una promesa es un objeto que representa una operación que puede tener éxito o fallar, y proporciona una forma de manejar el resultado de esa operación de manera asíncrona.\nEn resumen, las promesas permiten:\n\nManejar operaciones asíncronas de manera más fácil y legible\nProporcionar una forma de manejar errores y excepciones de manera más efectiva\nPermitir la composición de operaciones asíncronas de manera más sencilla\n\nUna promesa en JavaScript se crea utilizando la clase Promise y se puede resolver o rechazar. Cuando se crea una promesa, se puede proporcionar una función que se ejecutará cuando la promesa se resuelva o se rechace.\nLa sintaxis básica para crear una promesa es:\nconst promesa = new Promise((resolve, reject) =&gt; {\n  // código que se ejecuta\n  // si todo sale bien, se llama a resolve()\n  // si hay un error, se llama a reject()\n});\nDonde resolve y reject son funciones que se pasan como parámetros a la función constructora de la promesa.\n\nresolve: se llama cuando la operación se completa con éxito, y se pasa el resultado de la operación como parámetro.\nreject: se llama cuando la operación falla, y se pasa el error como parámetro.\n\nPor ejemplo:\nconst promesa = new Promise((resolve, reject) =&gt; {\n  // simulamos una operación que tarda 2 segundos\n  setTimeout(() =&gt; {\n    resolve(\"Operación completada con éxito\");\n  }, 2000);\n});\nEn este ejemplo, la promesa se resuelve después de 2 segundos y se pasa el mensaje “Operación completada con éxito” como parámetro a la función resolve.\n\n\nUna vez que la promesa se resuelve, se puede manejar el resultado utilizando el método then(). El método then() se llama con la función que se ejecutará cuando la promesa se resuelva.\nconst promesa = new Promise((resolve, reject) =&gt; {\n  // simulamos una operación que tarda 2 segundos\n  setTimeout(() =&gt; {\n    resolve(\"Operación completada con éxito\");\n  }, 2000);\n});\n\npromesa.then((resultado) =&gt; {\n  console.log(resultado); // \"Operación completada con éxito\"\n});\nEn este ejemplo, el método then() se llama con una función que recibe el resultado de la promesa como parámetro. La función se ejecuta cuando la promesa se resuelve y se imprime el resultado en la consola.\n\n\n\nSi la promesa se rechaza, se puede manejar el error utilizando el método catch(). El método catch() se llama con la función que se ejecutará cuando la promesa se rechace.\nconst promesa = new Promise((resolve, reject) =&gt; {\n  // simulamos una operación que falla\n  reject(\"Error en la operación\");\n});\n\npromesa.catch((error) =&gt; {\n  console.error(error); // \"Error en la operación\"\n});\nEn este ejemplo, el método catch() se llama con una función que recibe el error como parámetro. La función se ejecuta cuando la promesa se rechaza y se imprime el error en la consola.\n\n\n\nEl encadenamiento de promesas es una técnica que permite combinar varias operaciones asíncronas en una sola cadena de promesas. Esto permite manejar operaciones complejas de manera más fácil y legible.\nLa idea básica es que cada promesa devuelve otra promesa, lo que permite encadenar varias operaciones asíncronas. El método then() devuelve una nueva promesa que se puede utilizar para encadenar otra operación.\nAquí hay un ejemplo:\nconst promesa1 = new Promise((resolve, reject) =&gt; {\n  // simulamos una operación que tarda 2 segundos\n  setTimeout(() =&gt; {\n    resolve(\"Operación 1 completada con éxito\");\n  }, 2000);\n});\n\nconst promesa2 = promesa1.then((resultado) =&gt; {\n  console.log(resultado); // \"Operación 1 completada con éxito\"\n  return new Promise((resolve, reject) =&gt; {\n    // simulamos otra operación que tarda 3 segundos\n    setTimeout(() =&gt; {\n      resolve(\"Operación 2 completada con éxito\");\n    }, 3000);\n  });\n});\n\npromesa2.then((resultado) =&gt; {\n  console.log(resultado); // \"Operación 2 completada con éxito\"\n});\nEn este ejemplo, promesa1 se resuelve después de 2 segundos y devuelve una cadena de texto. Luego, promesa1 se pasa al método then(), que devuelve promesa2. promesa2 se resuelve después de 3 segundos y devuelve otra cadena de texto.\nEl encadenamiento de promesas permite manejar operaciones asíncronas de manera más fácil y legible. En lugar de tener que anidar callbacks dentro de callbacks, se pueden encadenar promesas para crear una cadena de operaciones asíncronas.\nVentajas del encadenamiento de promesas\nEl encadenamiento de promesas tiene varias ventajas:\n\nMejora la legibilidad del código: el código es más fácil de leer y entender.\nReduce la complejidad: el encadenamiento de promesas reduce la complejidad del código y hace que sea más fácil de mantener.\nMejora la gestión de errores: el encadenamiento de promesas permite manejar errores de manera más efectiva.\n\nAhora vamos a usar una promesa con catch error en el contexto de usar una API (application programming interface) para que quede más claro como se usan en la práctica\nfetch('https://api.example.com/users/1')\n .then(response =&gt; response.json())\n .then(usuario =&gt; {\n    console.log(`Nombre del usuario: ${usuario.name}`);\n  })\n .catch(error =&gt; {\n    console.error(`Error: ${error}`);\n  });\nEn este ejemplo, como hemos comentado usa el método then que devuelve una nueva promesa que se puede utilizar para encadenar otra operación. Si la llamada funciona, la promesa se transforma a json, luego se extrae nombre del usuario y se imprime en consola. Si no funciona la llamda debido a un problema de red o de API se atrapa y se imprime. Hay que tomar en cuenta que cuando ocurre un problema es muy importante saber interpretarlo. Los tipos de errores mas comunes y su significado se pueden ver en la siguiente figura:\n\n\n\nHTTP status code\n\n\n\n\n\nUn objeto Promesa en JavaScript puede estar en uno de los siguientes estados:\n\nPending (Pendiente): Es el estado inicial de la promesa, cuando se está ejecutando la operación asíncrona. En este estado, el resultado es undefined.\nFulfilled (Cumplida): Es el estado en el que la promesa se ha resuelto con éxito. En este estado, el resultado es un valor.\nRejected (Rechazada): Es el estado en el que la promesa se ha rechazado con un error. En este estado, el resultado es un objeto de error.\n\n\n\n\nUn objeto Promesa tiene dos propiedades:\n\nState (Estado): Indica el estado actual de la promesa (Pending, Fulfilled o Rejected).\nResult (Resultado): Es el valor o error que se devuelve cuando la promesa se resuelve o rechaza.\n\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\nhttps://www.w3schools.com/js/js_promise.asp\nhttps://www.linkedin.com/pulse/http-response-status-codes-mominur-rahman-yl89c/\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status\n\n\n\n\n\n\n\n\n\nCrea un bucle for en JS que imprima cada nombre en esta lista.\n  miLista = “velma”, “exploradora”, “jane”, “john”, “harry”\nCrea un bucle while que recorra la misma lista y también imprima los nombres. Nota: Recuerda crear un contador para que el ciclo no sea infinito.\n\n// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS\n\n\n\nCree una función de flecha que devuelva “Hola mundo”.\nEnlace a fichero JS"
  },
  {
    "objectID": "js_checkpoint8.html#qué-diferencia-a-javascript-de-cualquier-otro-lenguaje-de-programación",
    "href": "js_checkpoint8.html#qué-diferencia-a-javascript-de-cualquier-otro-lenguaje-de-programación",
    "title": "JS - CKP8",
    "section": "",
    "text": "JS icon\n\n\nJavascript se diferencia de otros lenguajes (como Java, Python, C, Ruby, etc.) en que es el único que puede ser interpretado por un web browser.\nLa razón de esto es historica, en 1995 fue cuando creado por la empresa Netscape que era predominante en el mercado queria un lenguaje que pareciera como Java. Aunque inicialmente se penso para manejar Front-End y Back-End, solo ha sido exitosa en el Front-End. Aun después de la desaparición del browser de Netscape, las compañias siguientes han continuado el uso de Javascript.\nReferencias\nhttps://snipcart.com/blog/why-javascript-benefits\nhttps://en.wikipedia.org/wiki/Netscape"
  },
  {
    "objectID": "js_checkpoint8.html#cuáles-son-algunos-tipos-de-datos-js",
    "href": "js_checkpoint8.html#cuáles-son-algunos-tipos-de-datos-js",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp"
  },
  {
    "objectID": "js_checkpoint8.html#cuáles-son-las-tres-funciones-de-string-en-js",
    "href": "js_checkpoint8.html#cuáles-son-las-tres-funciones-de-string-en-js",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JS, los objeto de clase string representan texto y existen diferentes métodos que se resumen en la siguiente imagen.\n\n\n\nJS String methods\n\n\nDentro de estos metodos encontramos funcionalidades que nos permiten manipular strings que son muy utiles en la gestión de datos.\nComo ejemplo de lo múltiples metodos, vamos a asumir que hemos obtenido un texto en mínuscula pero necesitamos hacer la primera letra del titulo en mayúscula:\nlet titulo = \"hola pequeños gatos\";\n\nlet tituloCapitalizado = titulo.charAt(0).toUpperCase() + titulo.slice(1);\n\nconsole.log(tituloCapitalizado);\nAhora imaginamos que queremos hacer un split de texto, extraer el segundo objeto y removemos espacios en blanco usando trim().\n\nlet texto = \"manzana, naranja, banana\";\n\n// Dividir el texto en un array usando la coma (\",\") como separador\nlet partes = texto.split(\",\");\n\nlet segundoObjeto = partes[1].trim();\nReferencias\nhttps://www.w3schools.com/jsref/jsref_obj_string.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-un-condicional",
    "href": "js_checkpoint8.html#qué-es-un-condicional",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JS, una operación condicional, como el nombre indica, permite tener diferentes caminos a tomar (bloques de código a ejecutar) en dependencia de si una condición o condiciones se cumplen.\nEsto se puede entender con un ejemplo cotidiano. Digamos que vamos caminando al trabajo de manera regular pero si es tarde tenemos que tomar el metro.\n\n\n\nEjemplo condicional básico\n\n\nComo vemos, el concepto de condicional es fácil de entender y lo usamos en nuestra vida cotidiana.\nAhora en JS, la sintaxis seria:\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  console.log(`Vamos en Metro que es tarde!`);\n}\nAhora complicamos un poco más la lógica para mostrar el caso de una condicional dentro de una condicional. Por ejemplo, si fuera tarde tomamos el metro pero si es muy tarde vamos a tomar un taxi.\n\n\n\nEjemplo condicional anidado\n\n\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  if (tiempoParaTrabajar &gt; limiteMetro){\n    console.log(`Vamos en Metro que es tarde!`);\n  } else {\n    console.log(`Vamos en Taxi que es muy tarde!`);\n  }\n}\nEn caso de que hubieran multiplies condiciones a probar usamos sintaxis: “if…else if…else”.\nif (condition1)\n  statement1\nelse if (condition2)\n  statement2\nelse if (condition3)\n  statement3\n// …\nelse\n  statementN\nVeamos un ejemplo donde dependencia de la edad pagamos un precio diferente en el cine\n\nlet edad = 15;         \nlet precioBase = 10;   \nlet precioFinal;       \n\n// Aplicar descuento por edad\nif (edad &lt; 12) {\n  \n  precioFinal = precioBase * 0.5;\n} else if (edad &gt;= 12 && edad &lt; 18) {\n \n  precioFinal = precioBase * 0.75;\n} else if (edad &gt;= 65) {\n  \n  precioFinal = precioBase * 0.7;\n} else {\n \n  precioFinal = precioBase;\n}\n\n//console.log(\"El precio de la entrada es: $\" + precioFinal);\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\nhttps://www.w3schools.com/js/js_if_else.asp"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-un-operador-ternario",
    "href": "js_checkpoint8.html#qué-es-un-operador-ternario",
    "title": "JS - CKP8",
    "section": "",
    "text": "JS ternary\n\n\nEl operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if…else.\ncondicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso\nPor ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).\nPrimero veamos como seria usando condicional tipo if … else :\n\nif (lecheLitros &gt;= 5) {\n  console.log(`No comprar leche!`);\n} else {\n  console.log(`Comprar leche!`);\n}\nAhora veamos un seudo código de operación ternaria:\nHayMenosQueUmbral ? ComprarLeche : NoComprarLeche\nEn código seria algo como:\nconst umbral = 5;\nlet lecheLitros = 26;\nconst comprarLeche = lecheLitros &gt;= umbral ? \"No comprar leche\" : \"Comprar Leche\";\nconsole.log(comprarLeche); // \"No comprar leche\"\nComo vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator\nhttps://www.w3schools.com/java/java_conditions_shorthand.asp\nhttps://www.tpointtech.com/ternary-operator-in-java"
  },
  {
    "objectID": "js_checkpoint8.html#cuál-es-la-diferencia-entre-una-declaración-de-función-y-una-expresión-de-función",
    "href": "js_checkpoint8.html#cuál-es-la-diferencia-entre-una-declaración-de-función-y-una-expresión-de-función",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JS, se pueden definir funciones de usando declaración de función y expresión de función. Vamos a ver ejemplos y diferencias.\n\n\nLa función se define usando la palabra clave function. Se le asigna un nombre y se pueden llamar y reusar en varios sitios.\nPor ejemplo, creamos una función que suma dos números de la siguiente manera:\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\nHoisting. Las declaraciones de funciones se elevan al inicio del contexto lo que permite llamar a la función antes de escribir la declaración en el código.\n\nsumarNumeros(1,3);// 4\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\n\n\n\nEn este caso, a una variable se le asigna la función que puede ser anónima o tener un nombre interno. Por ejemplo, en la siguiente expresión creamos la variable getRectArea que contiene una función anónima:\n\nconst getRectArea = function(width, height) {\n  return width * height;\n};\n\nconsole.log(getRectArea(3, 4));\n// Expected output: 12\nUn ejemplo de función con nombre podria ser:\n\nlet funcionConNombre = function miFuncion() {\n    console.log(\"Esta es una function expression con nombre.\");\n};\n\nfuncionConNombre();  //\n// Expected output: Esta es una function expression con nombre\nNo hosting. Lo que quiere decir que no se eleva y se tiene usar después de la asignación.\nUn uso común de expresiones de función es cuando se requiere una función como valor como cuando se usan callbacks.\nCallbacks son funciones que se pasan como argumento a otra función y se ejecuta después de que ocurra un evento o se completa un proceso. Este tipo de mecánismos se usa en operaciones asíncronas como manejar eventos o esperar a una respuesta de API, ya que permite que el código continua su ejecución sin bloquearse. Por ejemplo, en en sieguiente código se espera a que ocurra un evento (click) y cuando esto ocurre, se imprime en consola un mensaje:\n\nbutton.addEventListener(\"click\", function (event) {\n  console.log(\"button is clicked!\");\n});\nEs importante observar que la secuencia de ejecución con callbacks no es la secuencia en la que estan definidas pero más bien en la secuencia en la que son llamadas.Esto permite ir llamando a funciones de manera muy dinámicas y en respuesta a las acciones de lo que podría ser las necesidades de un usuario en una web app.\nReferencias\nhttps://www.w3schools.com/js/js_function_definition.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\nhttps://www.w3schools.com/js/js_callback.asp\nhttps://www.youtube.com/watch?v=kz_vwAF4NHI"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-la-palabra-clave-this-en-js",
    "href": "js_checkpoint8.html#qué-es-la-palabra-clave-this-en-js",
    "title": "JS - CKP8",
    "section": "",
    "text": "JS this\n\n\nThis es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra “this” se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a this.\nVamos a ver algunos ejemplos para entender mejor como usar this:\n\nAl llamar fuera de función, se refire al objeto de ventana global.\n\n\nconsole.log('this alone', this); // [object Window]\n\nAl llamar dentro de un objeto, nos referimos al objeto.\n\n\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getThis : function() {\n      return this;\n    }\n};\n\nconsole.log('this in object method', person.getThis());\nY de la misma manera, podemos usar this para llamar a otras propiedades del objeto\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getFullName : function() {\n      return this.name + ' ' + this.lastName;\n    }\n};\n\nconsole.log('this in object method', person.getFullName());\nHay otras posibles referencias de “this” que se resumen aqui:\n\nEn un método de un objeto, this se refiere al objeto.\nPor sí solo, this se refiere al objeto global.\nEn una función, this se refiere al objeto global.\nEn una función en modo estricto, this es undefined.\nEn un evento, this se refiere al elemento que recibió el evento.\nMétodos como call(), apply() y bind() pueden asignar this a cualquier objeto.\n\nReferencias\nhttps://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.w3schools.com/js/js_this.asp\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1"
  },
  {
    "objectID": "js_checkpoint8.html#ejercicio",
    "href": "js_checkpoint8.html#ejercicio",
    "title": "JS - CKP8",
    "section": "",
    "text": "// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS"
  },
  {
    "objectID": "js_checkpoint7.html",
    "href": "js_checkpoint7.html",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS icon\n\n\n\n\nJavascript se diferencia de otros lenguajes (como Java, Python, C, Ruby, etc.) en que es el único que puede ser interpretado por un web browser.\nLa razón de esto es historica, en 1995 fue cuando creado por la empresa Netscape que era predominante en el mercado queria un lenguaje que pareciera como Java. Aunque inicialmente se penso para manejar Front-End y Back-End, solo ha sido exitosa en el Front-End. Aun después de la desaparición del browser de Netscape, las compañias siguientes han continuado el uso de Javascript.\nReferencias\nhttps://snipcart.com/blog/why-javascript-benefits\nhttps://en.wikipedia.org/wiki/Netscape\n\n\n\nEn JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp\n\n\n\n\nEn JS, los objeto de clase string representan texto y existen diferentes métodos que se resumen en la siguiente imagen.\n\n\n\nJS String methods\n\n\nDentro de estos metodos encontramos funcionalidades que nos permiten manipular strings que son muy utiles en la gestión de datos.\nComo ejemplo de lo múltiples metodos, vamos a asumir que hemos obtenido un texto en mínuscula pero necesitamos hacer la primera letra del titulo en mayúscula:\nlet titulo = \"hola pequeños gatos\";\n\nlet tituloCapitalizado = titulo.charAt(0).toUpperCase() + titulo.slice(1);\n\nconsole.log(tituloCapitalizado);\nAhora imaginamos que queremos hacer un split de texto, extraer el segundo objeto y removemos espacios en blanco usando trim().\n\nlet texto = \"manzana, naranja, banana\";\n\n// Dividir el texto en un array usando la coma (\",\") como separador\nlet partes = texto.split(\",\");\n\nlet segundoObjeto = partes[1].trim();\nReferencias\nhttps://www.w3schools.com/jsref/jsref_obj_string.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String\n\n\n\nEn JS, una operación condicional, como el nombre indica, permite tener diferentes caminos a tomar (bloques de código a ejecutar) en dependencia de si una condición o condiciones se cumplen.\nEsto se puede entender con un ejemplo cotidiano. Digamos que vamos caminando al trabajo de manera regular pero si es tarde tenemos que tomar el metro.\n\n\n\nEjemplo condicional básico\n\n\nComo vemos, el concepto de condicional es fácil de entender y lo usamos en nuestra vida cotidiana.\nAhora en JS, la sintaxis seria:\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  console.log(`Vamos en Metro que es tarde!`);\n}\nAhora complicamos un poco más la lógica para mostrar el caso de una condicional dentro de una condicional. Por ejemplo, si fuera tarde tomamos el metro pero si es muy tarde vamos a tomar un taxi.\n\n\n\nEjemplo condicional anidado\n\n\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  if (tiempoParaTrabajar &gt; limiteMetro){\n    console.log(`Vamos en Metro que es tarde!`);\n  } else {\n    console.log(`Vamos en Taxi que es muy tarde!`);\n  }\n}\nEn caso de que hubieran multiplies condiciones a probar usamos sintaxis: “if…else if…else”.\nif (condition1)\n  statement1\nelse if (condition2)\n  statement2\nelse if (condition3)\n  statement3\n// …\nelse\n  statementN\nVeamos un ejemplo donde dependencia de la edad pagamos un precio diferente en el cine\n\nlet edad = 15;         \nlet precioBase = 10;   \nlet precioFinal;       \n\n// Aplicar descuento por edad\nif (edad &lt; 12) {\n  \n  precioFinal = precioBase * 0.5;\n} else if (edad &gt;= 12 && edad &lt; 18) {\n \n  precioFinal = precioBase * 0.75;\n} else if (edad &gt;= 65) {\n  \n  precioFinal = precioBase * 0.7;\n} else {\n \n  precioFinal = precioBase;\n}\n\n//console.log(\"El precio de la entrada es: $\" + precioFinal);\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\nhttps://www.w3schools.com/js/js_if_else.asp\n\n\n\n\n\n\nJS ternary\n\n\nEl operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if…else.\ncondicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso\nPor ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).\nPrimero veamos como seria usando condicional tipo if … else :\n\nif (lecheLitros &gt;= 5) {\n  console.log(`No comprar leche!`);\n} else {\n  console.log(`Comprar leche!`);\n}\nAhora veamos un seudo código de operación ternaria:\nHayMenosQueUmbral ? ComprarLeche : NoComprarLeche\nEn código seria algo como:\nconst umbral = 5;\nlet lecheLitros = 26;\nconst comprarLeche = lecheLitros &gt;= umbral ? \"No comprar leche\" : \"Comprar Leche\";\nconsole.log(comprarLeche); // \"No comprar leche\"\nComo vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator\nhttps://www.w3schools.com/java/java_conditions_shorthand.asp\nhttps://www.tpointtech.com/ternary-operator-in-java\n\n\n\nEn JS, se pueden definir funciones de usando declaración de función y expresión de función. Vamos a ver ejemplos y diferencias.\n\n\nLa función se define usando la palabra clave function. Se le asigna un nombre y se pueden llamar y reusar en varios sitios.\nPor ejemplo, creamos una función que suma dos números de la siguiente manera:\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\nHoisting. Las declaraciones de funciones se elevan al inicio del contexto lo que permite llamar a la función antes de escribir la declaración en el código.\n\nsumarNumeros(1,3);// 4\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\n\n\n\nEn este caso, a una variable se le asigna la función que puede ser anónima o tener un nombre interno. Por ejemplo, en la siguiente expresión creamos la variable getRectArea que contiene una función anónima:\n\nconst getRectArea = function(width, height) {\n  return width * height;\n};\n\nconsole.log(getRectArea(3, 4));\n// Expected output: 12\nUn ejemplo de función con nombre podria ser:\n\nlet funcionConNombre = function miFuncion() {\n    console.log(\"Esta es una function expression con nombre.\");\n};\n\nfuncionConNombre();  //\n// Expected output: Esta es una function expression con nombre\nNo hosting. Lo que quiere decir que no se eleva y se tiene usar después de la asignación.\nUn uso común de expresiones de función es cuando se requiere una función como valor como cuando se usan callbacks.\nCallbacks son funciones que se pasan como argumento a otra función y se ejecuta después de que ocurra un evento o se completa un proceso. Este tipo de mecánismos se usa en operaciones asíncronas como manejar eventos o esperar a una respuesta de API, ya que permite que el código continua su ejecución sin bloquearse. Por ejemplo, en en sieguiente código se espera a que ocurra un evento (click) y cuando esto ocurre, se imprime en consola un mensaje:\n\nbutton.addEventListener(\"click\", function (event) {\n  console.log(\"button is clicked!\");\n});\nEs importante observar que la secuencia de ejecución con callbacks no es la secuencia en la que estan definidas pero más bien en la secuencia en la que son llamadas.Esto permite ir llamando a funciones de manera muy dinámicas y en respuesta a las acciones de lo que podría ser las necesidades de un usuario en una web app.\nReferencias\nhttps://www.w3schools.com/js/js_function_definition.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\nhttps://www.w3schools.com/js/js_callback.asp\nhttps://www.youtube.com/watch?v=kz_vwAF4NHI\n\n\n\n\n\n\n\nJS this\n\n\nThis es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra “this” se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a this.\nVamos a ver algunos ejemplos para entender mejor como usar this:\n\nAl llamar fuera de función, se refire al objeto de ventana global.\n\n\nconsole.log('this alone', this); // [object Window]\n\nAl llamar dentro de un objeto, nos referimos al objeto.\n\n\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getThis : function() {\n      return this;\n    }\n};\n\nconsole.log('this in object method', person.getThis());\nY de la misma manera, podemos usar this para llamar a otras propiedades del objeto\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getFullName : function() {\n      return this.name + ' ' + this.lastName;\n    }\n};\n\nconsole.log('this in object method', person.getFullName());\nHay otras posibles referencias de “this” que se resumen aqui:\n\nEn un método de un objeto, this se refiere al objeto.\nPor sí solo, this se refiere al objeto global.\nEn una función, this se refiere al objeto global.\nEn una función en modo estricto, this es undefined.\nEn un evento, this se refiere al elemento que recibió el evento.\nMétodos como call(), apply() y bind() pueden asignar this a cualquier objeto.\n\nReferencias\nhttps://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.w3schools.com/js/js_this.asp\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1\n\n\n\n\n// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS"
  },
  {
    "objectID": "js_checkpoint7.html#qué-diferencia-a-javascript-de-cualquier-otro-lenguaje-de-programación",
    "href": "js_checkpoint7.html#qué-diferencia-a-javascript-de-cualquier-otro-lenguaje-de-programación",
    "title": "JS - CKP7",
    "section": "",
    "text": "Javascript se diferencia de otros lenguajes (como Java, Python, C, Ruby, etc.) en que es el único que puede ser interpretado por un web browser.\nLa razón de esto es historica, en 1995 fue cuando creado por la empresa Netscape que era predominante en el mercado queria un lenguaje que pareciera como Java. Aunque inicialmente se penso para manejar Front-End y Back-End, solo ha sido exitosa en el Front-End. Aun después de la desaparición del browser de Netscape, las compañias siguientes han continuado el uso de Javascript.\nReferencias\nhttps://snipcart.com/blog/why-javascript-benefits\nhttps://en.wikipedia.org/wiki/Netscape"
  },
  {
    "objectID": "js_checkpoint7.html#cuáles-son-algunos-tipos-de-datos-js",
    "href": "js_checkpoint7.html#cuáles-son-algunos-tipos-de-datos-js",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp"
  },
  {
    "objectID": "js_checkpoint7.html#cuáles-son-las-tres-funciones-de-string-en-js",
    "href": "js_checkpoint7.html#cuáles-son-las-tres-funciones-de-string-en-js",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JS, los objeto de clase string representan texto y existen diferentes métodos que se resumen en la siguiente imagen.\n\n\n\nJS String methods\n\n\nDentro de estos metodos encontramos funcionalidades que nos permiten manipular strings que son muy utiles en la gestión de datos.\nComo ejemplo de lo múltiples metodos, vamos a asumir que hemos obtenido un texto en mínuscula pero necesitamos hacer la primera letra del titulo en mayúscula:\nlet titulo = \"hola pequeños gatos\";\n\nlet tituloCapitalizado = titulo.charAt(0).toUpperCase() + titulo.slice(1);\n\nconsole.log(tituloCapitalizado);\nAhora imaginamos que queremos hacer un split de texto, extraer el segundo objeto y removemos espacios en blanco usando trim().\n\nlet texto = \"manzana, naranja, banana\";\n\n// Dividir el texto en un array usando la coma (\",\") como separador\nlet partes = texto.split(\",\");\n\nlet segundoObjeto = partes[1].trim();\nReferencias\nhttps://www.w3schools.com/jsref/jsref_obj_string.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"
  },
  {
    "objectID": "js_checkpoint7.html#qué-es-un-condicional",
    "href": "js_checkpoint7.html#qué-es-un-condicional",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JS, una operación condicional, como el nombre indica, permite tener diferentes caminos a tomar (bloques de código a ejecutar) en dependencia de si una condición o condiciones se cumplen.\nEsto se puede entender con un ejemplo cotidiano. Digamos que vamos caminando al trabajo de manera regular pero si es tarde tenemos que tomar el metro.\n\n\n\nEjemplo condicional básico\n\n\nComo vemos, el concepto de condicional es fácil de entender y lo usamos en nuestra vida cotidiana.\nAhora en JS, la sintaxis seria:\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  console.log(`Vamos en Metro que es tarde!`);\n}\nAhora complicamos un poco más la lógica para mostrar el caso de una condicional dentro de una condicional. Por ejemplo, si fuera tarde tomamos el metro pero si es muy tarde vamos a tomar un taxi.\n\n\n\nEjemplo condicional anidado\n\n\n\nlet tiempoParaTrabajar = 35;\nlet limiteCaminar = 30;\nlet limiteMetro = 15;\n\nif (tiempoParaTrabajar &gt; limiteCaminar) {\n  console.log(`Vamos caminando!`);\n} else {\n  if (tiempoParaTrabajar &gt; limiteMetro){\n    console.log(`Vamos en Metro que es tarde!`);\n  } else {\n    console.log(`Vamos en Taxi que es muy tarde!`);\n  }\n}\nEn caso de que hubieran multiplies condiciones a probar usamos sintaxis: “if…else if…else”.\nif (condition1)\n  statement1\nelse if (condition2)\n  statement2\nelse if (condition3)\n  statement3\n// …\nelse\n  statementN\nVeamos un ejemplo donde dependencia de la edad pagamos un precio diferente en el cine\n\nlet edad = 15;         \nlet precioBase = 10;   \nlet precioFinal;       \n\n// Aplicar descuento por edad\nif (edad &lt; 12) {\n  \n  precioFinal = precioBase * 0.5;\n} else if (edad &gt;= 12 && edad &lt; 18) {\n \n  precioFinal = precioBase * 0.75;\n} else if (edad &gt;= 65) {\n  \n  precioFinal = precioBase * 0.7;\n} else {\n \n  precioFinal = precioBase;\n}\n\n//console.log(\"El precio de la entrada es: $\" + precioFinal);\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else\nhttps://www.w3schools.com/js/js_if_else.asp"
  },
  {
    "objectID": "js_checkpoint7.html#qué-es-un-operador-ternario",
    "href": "js_checkpoint7.html#qué-es-un-operador-ternario",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS ternary\n\n\nEl operador condicional (ternario) es el único operador de JavaScript que toma tres operandos: una condición seguida de un signo de interrogación (?), luego una expresión que se ejecuta si la condición es verdadera y, a continuación, dos puntos (:) seguidos de la expresión que se ejecuta si la condición es falsa. Este operador se utiliza frecuentemente como una alternativa a la sentencia if…else.\ncondicion ? ExpresionEjecutaSiVerdadero : ExpresionEjecutaSiFalso\nPor ejemplo, imaginamos que hemos decidido comprar lecha cuando hay menos de 5 litros en casa (nos encanta hacer yogurt :D).\nPrimero veamos como seria usando condicional tipo if … else :\n\nif (lecheLitros &gt;= 5) {\n  console.log(`No comprar leche!`);\n} else {\n  console.log(`Comprar leche!`);\n}\nAhora veamos un seudo código de operación ternaria:\nHayMenosQueUmbral ? ComprarLeche : NoComprarLeche\nEn código seria algo como:\nconst umbral = 5;\nlet lecheLitros = 26;\nconst comprarLeche = lecheLitros &gt;= umbral ? \"No comprar leche\" : \"Comprar Leche\";\nconsole.log(comprarLeche); // \"No comprar leche\"\nComo vemos, la operación ternaria nos ofrece una manera de simplificar el código y la lectura en ciertos casos donde las condiciones son simples.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_operator\nhttps://www.w3schools.com/java/java_conditions_shorthand.asp\nhttps://www.tpointtech.com/ternary-operator-in-java"
  },
  {
    "objectID": "js_checkpoint7.html#cuál-es-la-diferencia-entre-una-declaración-de-función-y-una-expresión-de-función",
    "href": "js_checkpoint7.html#cuál-es-la-diferencia-entre-una-declaración-de-función-y-una-expresión-de-función",
    "title": "JS - CKP7",
    "section": "",
    "text": "En JS, se pueden definir funciones de usando declaración de función y expresión de función. Vamos a ver ejemplos y diferencias.\n\n\nLa función se define usando la palabra clave function. Se le asigna un nombre y se pueden llamar y reusar en varios sitios.\nPor ejemplo, creamos una función que suma dos números de la siguiente manera:\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\nHoisting. Las declaraciones de funciones se elevan al inicio del contexto lo que permite llamar a la función antes de escribir la declaración en el código.\n\nsumarNumeros(1,3);// 4\n\nfunction sumarNumeros(num1,num2){\n return num1 + num2;\n}\n\n\n\nEn este caso, a una variable se le asigna la función que puede ser anónima o tener un nombre interno. Por ejemplo, en la siguiente expresión creamos la variable getRectArea que contiene una función anónima:\n\nconst getRectArea = function(width, height) {\n  return width * height;\n};\n\nconsole.log(getRectArea(3, 4));\n// Expected output: 12\nUn ejemplo de función con nombre podria ser:\n\nlet funcionConNombre = function miFuncion() {\n    console.log(\"Esta es una function expression con nombre.\");\n};\n\nfuncionConNombre();  //\n// Expected output: Esta es una function expression con nombre\nNo hosting. Lo que quiere decir que no se eleva y se tiene usar después de la asignación.\nUn uso común de expresiones de función es cuando se requiere una función como valor como cuando se usan callbacks.\nCallbacks son funciones que se pasan como argumento a otra función y se ejecuta después de que ocurra un evento o se completa un proceso. Este tipo de mecánismos se usa en operaciones asíncronas como manejar eventos o esperar a una respuesta de API, ya que permite que el código continua su ejecución sin bloquearse. Por ejemplo, en en sieguiente código se espera a que ocurra un evento (click) y cuando esto ocurre, se imprime en consola un mensaje:\n\nbutton.addEventListener(\"click\", function (event) {\n  console.log(\"button is clicked!\");\n});\nEs importante observar que la secuencia de ejecución con callbacks no es la secuencia en la que estan definidas pero más bien en la secuencia en la que son llamadas.Esto permite ir llamando a funciones de manera muy dinámicas y en respuesta a las acciones de lo que podría ser las necesidades de un usuario en una web app.\nReferencias\nhttps://www.w3schools.com/js/js_function_definition.asp\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\nhttps://www.w3schools.com/js/js_callback.asp\nhttps://www.youtube.com/watch?v=kz_vwAF4NHI"
  },
  {
    "objectID": "js_checkpoint7.html#qué-es-la-palabra-clave-this-en-js",
    "href": "js_checkpoint7.html#qué-es-la-palabra-clave-this-en-js",
    "title": "JS - CKP7",
    "section": "",
    "text": "JS this\n\n\nThis es una palabra clave utilizada dentro de funciones y clases. Hace referencia al objeto en cuestión. En el caso de que estamos creando una función, la palabra “this” se usa para representar o llamar al objeto que dicha función esta modificando. El objeto al que se refiere varia en dependencia de cómo y donde se llama a this.\nVamos a ver algunos ejemplos para entender mejor como usar this:\n\nAl llamar fuera de función, se refire al objeto de ventana global.\n\n\nconsole.log('this alone', this); // [object Window]\n\nAl llamar dentro de un objeto, nos referimos al objeto.\n\n\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getThis : function() {\n      return this;\n    }\n};\n\nconsole.log('this in object method', person.getThis());\nY de la misma manera, podemos usar this para llamar a otras propiedades del objeto\nconst person = {\n    firstName: \"John\",\n    lastName : \"Doe\",\n    id       : 5566,\n    getFullName : function() {\n      return this.name + ' ' + this.lastName;\n    }\n};\n\nconsole.log('this in object method', person.getFullName());\nHay otras posibles referencias de “this” que se resumen aqui:\n\nEn un método de un objeto, this se refiere al objeto.\nPor sí solo, this se refiere al objeto global.\nEn una función, this se refiere al objeto global.\nEn una función en modo estricto, this es undefined.\nEn un evento, this se refiere al elemento que recibió el evento.\nMétodos como call(), apply() y bind() pueden asignar this a cualquier objeto.\n\nReferencias\nhttps://www.freecodecamp.org/espanol/news/como-usar-la-palabra-clave-this-en-javascript/\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.w3schools.com/js/js_this.asp\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1"
  },
  {
    "objectID": "js_checkpoint7.html#ejercicio",
    "href": "js_checkpoint7.html#ejercicio",
    "title": "JS - CKP7",
    "section": "",
    "text": "// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS"
  },
  {
    "objectID": "js_checkpoint8.html#cuáles-son-las-diferencias-entre-const-let-y-var",
    "href": "js_checkpoint8.html#cuáles-son-las-diferencias-entre-const-let-y-var",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JavaScript, const, let y var se utilizan para declarar variables, pero tienen diferencias clave en su alcance y comportamiento (hoisting, reglas de reasignación):\nHoisting: Es un comportamiento donde las declaraciones de variables se mueven a la parte superior del ambito en el que se declaran.\nvar: La variable declarada con var tiene un alcance de función o global, es decir, se aplica a toda la función en la que se declara. Puede ser redeclarada y reasignada.\nvar persona = { nombre: \"Ana\", edad: 28 };\n\nvar persona = { nombre: \"Fran\", edad: 25 };\nEjemplo de Hoisting para var donde se tiene:\n\nconsole.log(x); // undefined\nvar x = 10;\nDebido al hoisting, el código se ejecuta como si fuera la variable declarada y no asignada hasta después:\nvar x;\nconsole.log(x); // undefined\nx = 10;\nlet: La variable declarada con let tiene un alcance de bloque, es decir, se aplica solo dentro del bloque en el que se declara. Puede ser reasignada, pero no redeclarada.\nEn el siguiente ejemplo se observa como si se llama a una variable declarada dentro de función y se intenta llamar fuera del bloque nos da error:\nif (true) {\n    let nombre = \"Juan\";\n    console.log(nombre);\n}\nconsole.log(nombre); // Error: nombre is not defined\nEn otro ejemplo se usa let para declarar una variable global y luego otra local (dentro de función):\nlet edad = 25;\nif (true) {\n    let edad = 30; \n    console.log(edad); // 30\n}\nconsole.log(edad); // 25\nSe observa como la variable local solo es accesible dentro del bloque if y no afecta a la variable global.\nHoisting para let funciona diferente que para var, ya que que con let no se inicializa la variable y causa un error:\nconsole.log(number)\n// ReferenceError: Cannot access 'number' before initialization\n\nlet number = 50\nconst: La variable declarada con const también tiene un alcance de bloque, pero no puede ser reasignada ni redeclarada. Su valor es constante.\nconst edad = 30; \nedad = 35; // Error: Assignment to constant variable.\nHoisting para const es similar que para let donde no se inicializa variable y da error:\nconsole.log(number)\n// ReferenceError: Cannot access 'number' before initialization\n\nconst number = 50\nDebido a que usar variables antes de declararlas puede causar problemas, algunas veces se recomienda seguir la regla no-use-before-define o lo que es definir primero y hasta después usar.\nReferencias\nhttps://www.geeksforgeeks.org/difference-between-var-let-and-const-keywords-in-javascript/\nhttps://www.freecodecamp.org/news/differences-between-var-let-const-javascript/\nhttps://eslint.org/docs/latest/rules/no-use-before-define"
  },
  {
    "objectID": "js_checkpoint8.html#qué-tipo-de-bucles-hay-en-js",
    "href": "js_checkpoint8.html#qué-tipo-de-bucles-hay-en-js",
    "title": "JS - CKP8",
    "section": "",
    "text": "Tomado de https://www.linkedin.com/pulse/loop-while-dowhile-javascript-hadi-soufan/\n\n\nLos bucles son una manera de repetir un proceso. Los bucles más comunes son:\n\nFor: itera sobre una secuencia de elementos, como un array o un objeto.\nWhile: repite proceso mientras se cumple una condición.Si no se cumple, no se corre el proceso ninguna vez.\nDo-While: similar al bucle While, pero se ejecuta al menos una vez antes de evaluar la condición.\n\nVeamos ahora detalle de cada tipo de bucle y ejemplos de cada uno.\n\nBucle For\n\nEl bucle for es el más común y se utiliza para ejecutar un bloque de código un número determinado de veces. La sintaxis básica es:\nfor (inicialización; condición; incremento) {\n  // código a ejecutar\n}\nDonde:\ninicialización: es la expresión que se ejecuta antes de comenzar el bucle. condición: es la expresión que se evalúa en cada iteración para determinar si el bucle debe continuar. incremento: es la expresión que se ejecuta al final de cada iteración para actualizar la variable de control.\nEjemplo:\nfor (let i = 0; i &lt; 5; i++) {\n  console.log(i);\n}\n// Salida: 0, 1, 2, 3, 4\n\nBucle While\n\nEl bucle while se utiliza para ejecutar un bloque de código mientras se cumple una condición determinada. La sintaxis básica es:\nwhile (condición) {\n  // código a ejecutar\n}\nDonde condición es la expresión que se evalúa en cada iteración para determinar si el bucle debe continuar.\nEjemplo:\nlet i = 0;\nwhile (i &lt; 5) {\n  console.log(i);\n  i++;\n}\n// Salida: 0, 1, 2, 3, 4\n\nBucle Do-While\n\nEl bucle do-while es similar al bucle while, pero se ejecuta al menos una vez antes de evaluar la condición. La sintaxis básica es:\ndo {\n  // código a ejecutar\n} while (condición);\nDonde condición es la expresión que se evalúa en cada iteración para determinar si el bucle debe continuar.\nEl bucle Do-While se ejecuta de la siguiente manera:\n\nSe ejecuta el código dentro del bloque do al menos una vez.\nLuego, se evalúa la condición en la cláusula while.\nSi la condición es true, se vuelve a ejecutar el código dentro del bloque do.\nSi la condición es false, el bucle termina.\n\nEjemplo:\nlet i = 0;\ndo {\n  console.log(i);\n  i++;\n} while (i &lt; 5);\n// Salida: 0, 1, 2, 3, 4\nEn este ejemplo, el bucle Do-While se ejecuta al menos una vez, imprimiendo el valor de i (0). Luego, se evalúa la condición i &lt; 5, que es true, por lo que se vuelve a ejecutar el código dentro del bloque do, imprimiendo el valor de i (1). Esto continúa hasta que i sea 5, momento en el que la condición es false y el bucle termina.\nLa principal diferencia entre While y Do-While es que Do-While se ejecuta al menos una vez, mientras que While puede no ejecutarse nunca si la condición inicial es false.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration\nhttps://www.w3schools.com/jsref/jsref_dowhile.asp\nhttps://www.linkedin.com/pulse/loop-while-dowhile-javascript-hadi-soufan/"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-una-función-de-flecha",
    "href": "js_checkpoint8.html#qué-es-una-función-de-flecha",
    "title": "JS - CKP8",
    "section": "",
    "text": "Una función flecha es una forma concisa de definir una función en JavaScript. Se utiliza la sintaxis () =&gt; {} para crear una función anónima.\nEjemplo de una función normal (function declaration) que suma dos números:\nfunction sumar(a, b) {\n  return a + b;\n}\nLa versión con función anónima:\nvar sumar = function(a, b) {\n  return a + b;\n}\nAhora miramos versión de función flecha equivalente:\nconst sumar = (a, b) =&gt; a + b;\nconsole.log(sumar(2, 3)); // 5\nVariantes\nHay algunas variantes, por ejemplo los parentesis en los argumentos. En la función anterior usamos como argumentos (a,b) que nos regresa el resultado de expresión (a+b) pero en caso de que hubiera un solo argumento, los parentesis pueden ser omitidos. Por ejemplo en la siguiente expression la función puede ser escrita con o sin parentesis.\nlet double = n =&gt; n * 2;\n// igual que: let double = (n) =&gt; n * 2;\n// Muy similar a funcion anónima: let double = function(n) { return n * 2 }\n\nalert( double(3) ); // 6\nEn caso de que no hubiera argumentos, los parentesis tienen que estar vacios. Por ejemplo:\nlet saluda = () =&gt; alert(\"Hola\");\nsaluda();\nMultilinea.En caso de que se tenga que realizar varias expresiones dentro de la función se usa “{}” para englobar la diferentes lineas y se debe incluir “return” para que nos regrese algo, justo como en función normal. Veamos un ejemplo donde se evalua que los valores pasados a función son positivos y luego calcula el área:\nconst calcularArea = (base, altura) =&gt; {\n  if (base &lt;= 0 || altura &lt;= 0) {\n    throw new Error(\"La base y la altura deben ser números positivos\");\n  }\n  const area = base * altura;\n  return area;\n}\nCuándo usar funciones flecha\nSe recomienda usar funciones flecha en los siguientes casos:\n\nFunciones cortas y simples: Cuando la función es muy simple y no requiere una gran cantidad de código, las funciones flecha son ideales.\nCallbacks: Las funciones flecha son útiles como callbacks, ya que son más concisas y fáciles de leer.\nFunciones anónimas: Las funciones flecha son una forma natural de crear funciones anónimas.\nMap, filter, reduce: Las funciones flecha son ideales para usar con métodos de arrays como map, filter y reduce.\n\nEjemplo de uso con map:\nconst numbers = [1, 2, 3, 4, 5];\nconst doubles = numbers.map((num) =&gt; num * 2);\nconsole.log(doubles); // [2, 4, 6, 8, 10]\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\nhttps://www.w3schools.com/js/js_arrow_function.asp\nhttps://javascript.info/arrow-functions-basics"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-la-deconstrucción-de-variables",
    "href": "js_checkpoint8.html#qué-es-la-deconstrucción-de-variables",
    "title": "JS - CKP8",
    "section": "",
    "text": "Tomado de www.samanthaming.com\n\n\nLa deconstrucción de variables es una forma de asignar valores a variables a partir de un objeto o un array.\nSe utiliza la sintaxis para objeto: { variable1, variable2, ... } = objeto\nSe utiliza la sintaxis para array: [variable1, variable2, ...] = array.\nLa deconstrucción de variables es útil para simplificar el código y evitar la necesidad de acceder a las propiedades de un objeto o los elementos de un array mediante su índice o nombre.\nVeamos como funciona con algunos ejemplos:\n// Deconstrucción de objeto\nconst persona = { nombre: \"Juan\", edad: 30 };\nconst { nombre, edad } = persona;\n\nconsole.log(nombre); // Output: \"Juan\"\nconsole.log(edad); // Output: 30\nY para un array tenemos:\n// Deconstrucción de array\nconst frutas = [\"manzana\", \"banana\", \"naranja\"];\nconst [fruta1, fruta2, fruta3] = frutas;\n\nconsole.log(fruta1); // Output: \"manzana\"\nconsole.log(fruta2); // Output: \"banana\"\nconsole.log(fruta3); // Output: \"naranja\"\nValores predeterminados\nA una variable se le puede asignar un valor predeterminado, en el caso de que el valor desempacado del arreglo sea undefined.\nVeamos un ejemplo para objeto donde se desestructura el objeto persona y se asignan valores predeterminados a las variables nombre, edad y pais. Si el objeto persona no tiene una propiedad con el nombre correspondiente, se asigna el valor predeterminado.\nconst persona = { nombre: \"Juan\", edad: 30 };\nconst { nombre = \"Desconocido\", edad = 0, pais = \"No especificado\" } = persona;\n\nconsole.log(nombre); // \"Juan\"\nconsole.log(edad);   // 30\nconsole.log(pais);   // \"No especificado\"\nAhora veamos un ejemplo usando array donde se desestructura el array colores y se asignan valores predeterminados a las variables primero, segundo y tercero. Si el array colores no tiene suficientes elementos, se asignan los valores predeterminados a las variables restantes.\nconst colores = [\"rojo\", \"azul\"];\nconst [primero = \"negro\", segundo = \"blanco\", tercero = \"gris\"] = colores;\n\nconsole.log(primero); // \"rojo\"\nconsole.log(segundo); // \"azul\"\nconsole.log(tercero); // \"gris\"\nIgnorar valores devueltos\nSe puede ignorar los valores que no interesan para evitar crear variables que no se usan y hay varias opciones. Aqui unos ejemplos:\n// ❌ Malo, asignación de variable inútil\nconst [ignore, keep] = ['ignore', 'keep']; // La variable \"ignore\" no se utiliza\n\n// ✅ Bueno, espacio en blanco\nconst [, keep] = ['ignore', 'keep']; // Se ignora el primer valor\n\n// ✅ Bueno, guion bajo\nconst [_ignore, keep] = ['ignore', 'keep']; // Se ignora el primer valor y se indica con \"_\"\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring\nhttps://www.w3schools.com/js/js_destructuring.asp\nhttps://dmitripavlutin.com/javascript-object-destructuring/\nhttps://www.samanthaming.com/tidbits/13-skip-values-in-destructuring/"
  },
  {
    "objectID": "js_checkpoint8.html#qué-hace-el-operador-de-extensión-en-js",
    "href": "js_checkpoint8.html#qué-hace-el-operador-de-extensión-en-js",
    "title": "JS - CKP8",
    "section": "",
    "text": "El operador de extensión o spread syntax(...) se utiliza para expandir un array o un objeto en una nueva estructura de datos. La sintaxis extendida permite a un elemento iterable tal como un arreglo o cadena ser expandido en lugares donde cero o más argumentos (para llamadas de función) o elementos (para Array literales) son esperados, o a un objeto ser expandido en lugares donde cero o más pares de valores clave (para literales Tipo Objeto) son esperados.\n// Expansión de array\nconst numeros = [1, 2, 3];\nconst nuevosNumeros = [...numeros, 4, 5, 6];\n\nconsole.log(nuevosNumeros); // Output: [1, 2, 3, 4, 5, 6]\n\n// Expansión de objeto\nconst persona = { nombre: \"Juan\", edad: 30 };\nconst nuevaPersona = { ...persona, direccion: \"Calle 123\" };\n\nconsole.log(nuevaPersona); // Output: { nombre: \"Juan\", edad: 30, direccion: \"Calle 123\" }\nEl operador de extensión es útil para crear copias de arrays y objetos, y para combinar datos de diferentes fuentes.\nCrear copias\nEn el contexto de crear copias, se utiliza para crear una copia superficial de un array o un objeto.\n\nCopiar arrays\n\nPara copiar un array, puedes utilizar el operador de propagación de la siguiente manera:\nconst original = [1, 2, 3];\nconst copia = [...original];\n\nconsole.log(copia); // [1, 2, 3]\nEn este ejemplo, se crea una copia del array original utilizando el operador de propagación (…). La copia se almacena en la variable copia.\n\nCopiar objetos\n\nDe manera similar, puedes copiar un objeto utilizando el operador de propagación:\nconst original = { a: 1, b: 2 };\nconst copia = { ...original };\n\nconsole.log(copia); // { a: 1, b: 2 }\nSi te preguntas que es una copia superficial aqui se explica. La copia creada con el operador de propagación se llama “copia superficial” (o “shallow copy” en inglés) porque solo copia los valores de las propiedades del objeto o los elementos del array de manera directa, sin copiar los objetos o arrays anidados.\nEn otras palabras, si el objeto o array original contiene referencias a otros objetos o arrays, la copia solo copiará las referencias, no los objetos o arrays en sí mismos. Esto significa que si se modifica el objeto o array original, la copia también se verá afectada, ya que ambos comparten las mismas referencias.\nAquí hay un ejemplo:\n\nconst original = {\n  a: 1,\n  b: [2, 3],\n  c: { d: 4 }\n};\n\nconst copia = { ...original };\n\ncopia.b.push(5);\ncopia.c.d = 6;\n\nconsole.log(original); // { a: 1, b: [2, 3, 5], c: { d: 6 } }\nconsole.log(copia); // { a: 1, b: [2, 3, 5], c: { d: 6 } }\nEn este ejemplo, el objeto original se ve afectada por las modificaciones realizadas en el objeto copia, ya que ambos comparten las mismas referencias a los arrays y objetos anidados.\nPara crear una copia profunda (o “deep copy”) que no comparta referencias con el objeto original, se necesitan técnicas más avanzadas, como la recursividad o la utilización de bibliotecas como Lodash\nCombinar datos\nEl operador de propagación (spread syntax) también se puede utilizar para combinar datos de diferentes fuentes en un nuevo array o objeto.\n\nCombinar arrays\n\nPara combinar dos o más arrays, puedes utilizar el operador de propagación de la siguiente manera:\nconst array1 = [1, 2, 3];\nconst array2 = [4, 5, 6];\n\nconst combinado = [...array1, ...array2];\n\nconsole.log(combinado); // [1, 2, 3, 4, 5, 6]\nEn este ejemplo, se combinan los arrays array1 y array2 en un nuevo array llamado combinado.\n\nCombinar objetos\n\nDe manera similar, puedes combinar dos o más objetos utilizando el operador de propagación:\nconst objeto1 = { a: 1, b: 2 };\nconst objeto2 = { c: 3, d: 4 };\n\nconst combinado = {...objeto1, ...objeto2};\n\nconsole.log(combinado); // { a: 1, b: 2, c: 3, d: 4 }\nEn este ejemplo, se combinan los objetos objeto1 y objeto2 en un nuevo objeto llamado combinado.\nCombinar arrays y objetos.También puedes combinar arrays y objetos utilizando el operador de propagación:\nconst array = [1, 2, 3];\nconst objeto = { a: 4, b: 5 };\n\nconst combinado = [...array, objeto];\n\nconsole.log(combinado); // [1, 2, 3, { a: 4, b: 5 }]\nEn este ejemplo, se combina el array array con el objeto objeto en un nuevo array llamado combinado.\nSobrescritura de propiedades\nCuando se combinan objetos utilizando el operador de propagación, si dos o más objetos tienen propiedades con el mismo nombre, la propiedad del objeto que se combina en segundo lugar sobrescribirá la propiedad del objeto que se combina en primer lugar.\nAquí hay un ejemplo:\nconst objeto1 = { a: 1, b: 2 };\nconst objeto2 = { b: 3, c: 4 };\n\nconst combinado = {...objeto1, ...objeto2};\n\nconsole.log(combinado); // { a: 1, b: 3, c: 4 }\nEn este ejemplo, la propiedad b del objeto objeto2 sobrescribe la propiedad b del objeto objeto1, por lo que el valor de b en el objeto combinado es 3, no 2.\nEs importante tener en cuenta que esto se aplica a todas las propiedades que se combinan, no solo a las que tienen el mismo nombre. Si un objeto tiene una propiedad que no existe en el otro objeto, se agregará al objeto combinado sin problemas.\nAquí hay un ejemplo con múltiples objetos:\nconst objeto1 = { a: 1, b: 2 };\nconst objeto2 = { b: 3, c: 4 };\nconst objeto3 = { c: 5, d: 6 };\n\nconst combinado = {...objeto1, ...objeto2, ...objeto3};\n\nconsole.log(combinado); // { a: 1, b: 3, c: 5, d: 6 }\nEn este ejemplo, la propiedad b del objeto objeto2 sobrescribe la propiedad b del objeto objeto1, y la propiedad c del objeto objeto3 sobrescribe la propiedad c del objeto objeto2. El objeto combinado tiene las propiedades de todos los objetos, con las sobrescrituras correspondientes.\nEn llamadas de función\nEl operador de propagación (spread syntax) se puede utilizar en llamadas de función para pasar argumentos de manera flexible y conveniente.\nPasar argumentos como array\nEn JavaScript, cuando se llama a una función, se pueden pasar argumentos de manera individual, como en el siguiente ejemplo:\nfunction suma(a, b, c) {\n  return a + b + c;\n}\n\nconst resultado = suma(1, 2, 3);\nconsole.log(resultado); // 6\nSin embargo, si se tiene un array de valores que se desean pasar como argumentos, se puede utilizar el operador de propagación para “desempacar” el array y pasar sus elementos como argumentos individuales:\nfunction suma(a, b, c) {\n  return a + b + c;\n}\n\nconst valores = [1, 2, 3];\nconst resultado = suma(...valores);\nconsole.log(resultado); // 6\nEn este ejemplo, el operador de propagación (…) se utiliza para “desempacar” el array valores y pasar sus elementos como argumentos individuales a la función suma.\notra aplicación importante del operador de propagación en funciones: permitir que una función acepte un número variable de argumentos.\nFunciones con un número variable de argumentos\nEn JavaScript, se puede definir una función que acepte un número variable de argumentos utilizando el operador de propagación en la lista de parámetros. Esto se conoce como “rest parameter” (parámetro de resto).\nAquí hay un ejemplo:\nfunction suma(...numeros) {\n  return numeros.reduce((a, b) =&gt; a + b, 0);\n}\n\nconsole.log(suma(1, 2, 3)); // 6\nconsole.log(suma(1, 2, 3, 4, 5)); // 15\nEn este ejemplo, la función suma acepta un número variable de argumentos, que se almacenan en el array numeros. La función utiliza el método reduce para sumar todos los números en el array y devolver el resultado.\nEl operador de propagación (…) se utiliza para indicar que el parámetro numeros es un parámetro de resto, que puede aceptar cualquier número de argumentos.\nDe esta manera, la función suma puede ser llamada con cualquier número de argumentos, y siempre devolverá la suma de todos los números pasados como argumentos.\nOtro ejemplo\nAquí hay otro ejemplo de una función que utiliza el operador de propagación para aceptar un número variable de argumentos:\n\nfunction max(...numeros) {\n  return Math.max(...numeros);\n}\n\nconsole.log(max(1, 2, 3)); // 3\nconsole.log(max(1, 2, 3, 4, 5)); // 5\nEn este ejemplo, la función max acepta un número variable de argumentos y devuelve el máximo de todos los números pasados como argumentos.\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax\nhttps://www.w3schools.com/howto/howto_js_spread_operator.asp\nhttps://lodash.com/\nhttps://www.geeksforgeeks.org/lodash-_-clonedeep-method/"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-la-programación-orientada-a-objetos",
    "href": "js_checkpoint8.html#qué-es-la-programación-orientada-a-objetos",
    "title": "JS - CKP8",
    "section": "",
    "text": "La programación orientada a objetos (POO) es un paradigma de programación que se centra en la creación de objetos que tienen propiedades y métodos que describen su comportamiento. En JavaScript, la POO se utiliza para crear objetos que pueden interactuar entre sí y con otros objetos.\nCreación de objetos en JavaScript\nEn JavaScript, los objetos se pueden crear de dos maneras:\n\nSintaxis de objeto literal.\n\nEsta es la forma más común de crear objetos en JavaScript. Se utiliza la sintaxis {} para crear un objeto y se pueden agregar propiedades y métodos utilizando la sintaxis clave: valor\n// Ejemplo de objeto en JavaScript\nconst persona = {\n  nombre: \"Ernesto\",\n  edad: 41,\n  profesion: \"ingeniero ambiental\",\n  saludar: function() {\n    console.log(`Hola, me llamo ${this.nombre}, tengo ${this.edad} años y trabajo como ${profesion}`);\n  }\n};\n\npersona.saludar(); // Output: \"Hola, me llamo Ernesto, tengo 41 años y trabajo como ingeniero ambiental\"\nEn este ejemplo, se crea un objeto persona con tres propiedades: nombre, edad, profesión y el método saludar. La propiedad saludar es un método que se puede llamar para saludar.\n\nConstructores.\n\nLos constructores son funciones especiales que se utilizan para crear objetos. Se utilizan la palabra clave new para crear un objeto a partir de un constructor.\nfunction Persona(nombre, edad, profesion) {\n  this.nombre = nombre;\n  this.edad = edad;\n  this.profesion = profesion;\n  this.saludar = function() {\n    console.log(`Hola, me llamo ${this.nombre}`);\n  };\n}\n\nconst persona = new Persona('Ines', 30, \"Doctora\");\nEn este ejemplo, se define un constructor Persona que toma tres parámetros: nombre, edad y profesión. El constructor crea un objeto con las propiedades nombre, edad, profesión y el método saludar. Luego, se crea un objeto persona utilizando el constructor Persona y la palabra clave new.\nDiferencias entre la sintaxis de objeto literal y los constructores\nLa principal diferencia entre la sintaxis de objeto literal y los constructores es la forma en que se crean los objetos. La sintaxis de objeto literal es más concisa y fácil de leer, mientras que los constructores ofrecen más flexibilidad y permiten la creación de objetos con propiedades y métodos dinámicos.\nHerencia\nLa herencia es un concepto fundamental en la Programación Orientada a Objetos (OOP) que permite crear una nueva clase a partir de una clase existente, heredando sus propiedades y métodos. En JavaScript, la herencia se puede implementar utilizando la palabra clave extends y la función constructor.\nEjemplo de herencia\nSupongamos que tenemos una clase Vehiculo que tiene propiedades como marca, modelo y año, y métodos como arrancar y detener. Queremos crear una clase Coche que herede las propiedades y métodos de Vehiculo y agregue algunas propiedades y métodos adicionales.\n// Clase Vehiculo\nclass Vehiculo {\n  constructor(marca, modelo, año) {\n    this.marca = marca;\n    this.modelo = modelo;\n    this.año = año;\n  }\n\n  arrancar() {\n    console.log(`El vehículo ${this.marca} ${this.modelo} está arrancando`);\n  }\n\n  detener() {\n    console.log(`El vehículo ${this.marca} ${this.modelo} está deteniendo`);\n  }\n}\n\n// Clase Coche que hereda de Vehiculo\nclass Coche extends Vehiculo {\n  constructor(marca, modelo, año, puertas) {\n    super(marca, modelo, año);\n    this.puertas = puertas;\n  }\n\n  abrirPuertas() {\n    console.log(`Se abren las ${this.puertas} puertas del coche ${this.marca} ${this.modelo}`);\n  }\n}\nLa clase Coche hereda de Vehiculo utilizando la palabra clave extends. El constructor de Coche llama al constructor de Vehiculo utilizando la función super, pasando los parámetros marca, modelo y año. Luego, inicializa la propiedad puertas propia de la clase Coche.\nLa función super se utiliza para llamar al constructor de la clase padre (en este caso, Vehiculo) y heredar sus propiedades y métodos. De esta manera, la clase Coche tiene acceso a las propiedades y métodos de Vehiculo, como marca, modelo, año, arrancar y detener, y puede agregar sus propias propiedades y métodos, como puertas y abrirPuertas.\nA continuación se presenta ejemplo de como usar clase Coche que hereda de vehiculo:\n// Crear un objeto de la clase Coche\nconst miCoche = new Coche('Toyota', 'Corolla', 2015, 4);\n\n// Llamar a los métodos heredados de Vehiculo\nmiCoche.arrancar(); // El vehículo Toyota Corolla está arrancando\nmiCoche.detener(); // El vehículo Toyota Corolla está deteniendo\n\n// Llamar al método propio de Coche\nmiCoche.abrirPuertas(); // Se abren las 4 puertas del coche Toyota Corolla\n\n// Acceder a las propiedades\nconsole.log(miCoche.marca); // Toyota\nconsole.log(miCoche.modelo); // Corolla\nconsole.log(miCoche.año); // 2015\nconsole.log(miCoche.puertas); // 4\nEn este ejemplo, creamos un objeto miCoche de la clase Coche, pasando los parámetros marca, modelo, año y puertas. Luego, llamamos a los métodos heredados de Vehiculo, como arrancar y detener, y al método propio de Coche, como abrirPuertas.\nReferencias\nhttps://www.w3schools.com/js/js_object_constructors.asp\nhttps://keepcoding.io/blog/que-es-this-en-javascript/\nhttps://www.geeksforgeeks.org/introduction-object-oriented-programming-javascript/\nhttps://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1"
  },
  {
    "objectID": "js_checkpoint8.html#ejercicios",
    "href": "js_checkpoint8.html#ejercicios",
    "title": "JS - CKP8",
    "section": "",
    "text": "Crea un bucle for en JS que imprima cada nombre en esta lista.\n  miLista = “velma”, “exploradora”, “jane”, “john”, “harry”\nCrea un bucle while que recorra la misma lista y también imprima los nombres. Nota: Recuerda crear un contador para que el ciclo no sea infinito.\n\n// ejercicio.js\n\n/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes\nSi el número creado es mayor que 50, la consola registra \"¡El número es mayor que 50!\". \nSi es más pequeño, la consola registra \"¡El número es menor que 50!\"\n*/\nfunction myFunctionSumaMultiplica(num1, num2,num3,num4) {\n    \n// Verificar que se hayan pasado exactamente 4 argumentos\nif (arguments.length !== 4) {\n    console.log(\"Error de cantidad: se deben pasar 4 argumentos.\");\n    return;\n}\n\n// Verificar que todos sean números\nif (\n    typeof num1 !== 'number' ||\n    typeof num2 !== 'number' ||\n    typeof num3 !== 'number' ||\n    typeof num4 !== 'number'\n) {\n    console.log(\"Error de tipo: todos los 4 argumentos deben ser números.\");\n    return;\n}\n    \n    let suma1 = num1 + num2;\n    let suma2 = num3 + num4;\n    let producto = suma1 * suma2;\n    if (producto &gt; 50) {\n        console.log(`¡El número ${producto} es mayor que 50!`);\n    }\n    else if (producto === 50) {\n        console.log(`¡El número ${producto} es igual a 50!`);\n    }\n    else {\n        console.log(`¡El número ${producto} es menor que 50!`);\n    }\n\n    \n  }\n\n//llama a la funcion y muestra el resultado en consola\n//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);\n\n// ejemplo con error de tipo\n//var resultado2 = myFunctionSumaMultiplica(2.5, 3, \"4\", 2);\n// ejemplo con error de cantidad de argumentos\n//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);\n\n\n\n\n\n\nEnlace a fichero JS\n\n\n\nCree una función de flecha que devuelva “Hola mundo”.\nEnlace a fichero JS"
  },
  {
    "objectID": "js_checkpoint8.html#qué-tipo-de-bucles-hay-en-js-1",
    "href": "js_checkpoint8.html#qué-tipo-de-bucles-hay-en-js-1",
    "title": "JS - CKP8",
    "section": "",
    "text": "En JavaScript existen diferentes tipos de datos que se pueden clasificar principalmente en dos grandes categorías: tipos primitivos y tipos complejos (también llamados objetos). A continuación, se desarrolla cada uno de estos grupos junto con ejemplos y explicaciones de su funcionamiento.\n\n\nLos tipos primitivos son aquellos que se almacenan y se gestionan por valor. Esto significa que cuando asignas o pasas un valor primitivo, se copia literalmente su valor en memoria. Algunas características clave de los tipos primitivos son:\nInmutabilidad: Una vez creado, el valor primitivo no puede cambiar; en lugar de modificarlo, se crea uno nuevo si se asigna un valor distinto.\nSin métodos propios: Aunque JavaScript permite acceder a métodos en tipos primitivos a través de un proceso llamado autoboxing (envoltura automática), en esencia estos valores no poseen métodos propios como los objetos.\nLos tipos primitivos en JavaScript incluyen:\nNumber: Para representar tanto enteros como números con decimales. Sin embargo tiene limites:\nNúmeros flotantes: Puedes trabajar con números muy pequeños y muy grandes, tanto positivos como negativos, que tienen decimales.\nNúmeros enteros: Aunque puedes usar números enteros, JavaScript garantiza que sean precisos solo si están en el rango seguro, que es desde -(2^53 − 1) hasta 2^53 − 1. Si el número entero está fuera de este rango, ya no se representa con total precisión y se convierte en una aproximación de punto flotante.\nVerificación: Puedes usar la función Number.isSafeInteger() para comprobar si un número entero está dentro de ese rango seguro.\nString: Cadenas de caracteres.\nCodificación y Posición: Los strings se codifican usando UTF-16, lo que significa que cada carácter se guarda como un valor numérico de 16 bits. Cada carácter ocupa una posición numerada, donde el primer carácter está en el índice 0, el siguiente en el 1, y así sucesivamente. La propiedad length de un string indica el número de unidades UTF-16, que puede no coincidir exactamente con la cantidad real de caracteres en todos los casos.\nInmutabilidad: Las cadenas son inmutables, lo que significa que una vez creada una cadena, no se puede modificar directamente. Si necesitas cambiarla, las operaciones como extraer una parte del texto (usando substring()) o unir dos cadenas (con el operador + o concat()) generan una nueva cadena sin alterar la original.\nBoolean: Valores lógicos true y false. Usualmene usados en operaciones con condicionales.\nNull: Representa la ausencia intencional de cualquier valor u objeto.\nUndefined: Indica que una variable ha sido declarada pero aún no se le ha asignado ningún valor.\nSymbol: Introducido en ES6, se utiliza para crear identificadores únicos para propiedades de objetos.\nBigInt: Introducido en versiones más recientes (ES2020), permite trabajar con números enteros de gran magnitud que superan el límite del tipo Number.\nEn la siguiente tabla se puede resumir los tipos primitivos, los valores que regresa y correspondiente clase o tipo de objeto que lo contiene:\n\n\n\nJS types\n\n\n\n\n\nLos tipos complejos, o objetos, se gestionan por referencia. Esto significa que cuando asignas o pasas un objeto, lo que se copia es la referencia a la ubicación en memoria donde se encuentra ese objeto. Algunas características de los objetos son:\nMutabilidad: A diferencia de los primitivos, los objetos pueden modificarse después de su creación. Por ejemplo, puedes añadir, modificar o eliminar propiedades.\nColección de propiedades y métodos: Un objeto puede contener datos (propiedades) y funcionalidades (métodos).\nHerencia prototípica: JavaScript utiliza prototipos para heredar propiedades y métodos entre objetos, lo que permite crear estructuras de datos más complejas y reutilizables.\nDentro de la categoría de objetos se incluyen:\nObjetos literales: Se definen directamente usando pares de clave valor y permite almacenar diferentes atributos relacionados de manera flexible, por ejemplo,\nlet persona = { nombre: \"Ana\", edad: 28 };\nArrays: Son objetos especializados para almacenar colecciones ordenadas de datos,\nlet numeros = [1, 2, 3, 4];\nFunciones: En JavaScript, las funciones se consideran objetos de primera clase, lo que significa que pueden asignarse a variables, pasarse como argumentos o devolverse desde otras funciones,\n\nfunction saludar() {\n        console.log(\"Hola\");\n    }\n\n\n\n\n\n\nOtros objetos: Como Date, RegExp, Map, Set, entre otros, que proporcionan funcionalidades específicas para manejar fechas, expresiones regulares y colecciones de valores.\nReferencia:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Data_structures\nhttps://brainstation.io/learn/javascript/data-types\nhttps://www.w3schools.com/js/js_typeof.asp"
  },
  {
    "objectID": "js_checkpoint8.html#qué-es-una-promesa-en-js",
    "href": "js_checkpoint8.html#qué-es-una-promesa-en-js",
    "title": "JS - CKP8",
    "section": "",
    "text": "Las promesas en JavaScript son un mecanismo para manejar operaciones asíncronas, como solicitudes de red, lecturas de archivos o bases de datos, de manera más eficiente y fácil de entender. Una promesa es un objeto que representa una operación que puede tener éxito o fallar, y proporciona una forma de manejar el resultado de esa operación de manera asíncrona.\nEn resumen, las promesas permiten:\n\nManejar operaciones asíncronas de manera más fácil y legible\nProporcionar una forma de manejar errores y excepciones de manera más efectiva\nPermitir la composición de operaciones asíncronas de manera más sencilla\n\nUna promesa en JavaScript se crea utilizando la clase Promise y se puede resolver o rechazar. Cuando se crea una promesa, se puede proporcionar una función que se ejecutará cuando la promesa se resuelva o se rechace.\nLa sintaxis básica para crear una promesa es:\nconst promesa = new Promise((resolve, reject) =&gt; {\n  // código que se ejecuta\n  // si todo sale bien, se llama a resolve()\n  // si hay un error, se llama a reject()\n});\nDonde resolve y reject son funciones que se pasan como parámetros a la función constructora de la promesa.\n\nresolve: se llama cuando la operación se completa con éxito, y se pasa el resultado de la operación como parámetro.\nreject: se llama cuando la operación falla, y se pasa el error como parámetro.\n\nPor ejemplo:\nconst promesa = new Promise((resolve, reject) =&gt; {\n  // simulamos una operación que tarda 2 segundos\n  setTimeout(() =&gt; {\n    resolve(\"Operación completada con éxito\");\n  }, 2000);\n});\nEn este ejemplo, la promesa se resuelve después de 2 segundos y se pasa el mensaje “Operación completada con éxito” como parámetro a la función resolve.\n\n\nUna vez que la promesa se resuelve, se puede manejar el resultado utilizando el método then(). El método then() se llama con la función que se ejecutará cuando la promesa se resuelva.\nconst promesa = new Promise((resolve, reject) =&gt; {\n  // simulamos una operación que tarda 2 segundos\n  setTimeout(() =&gt; {\n    resolve(\"Operación completada con éxito\");\n  }, 2000);\n});\n\npromesa.then((resultado) =&gt; {\n  console.log(resultado); // \"Operación completada con éxito\"\n});\nEn este ejemplo, el método then() se llama con una función que recibe el resultado de la promesa como parámetro. La función se ejecuta cuando la promesa se resuelve y se imprime el resultado en la consola.\n\n\n\nSi la promesa se rechaza, se puede manejar el error utilizando el método catch(). El método catch() se llama con la función que se ejecutará cuando la promesa se rechace.\nconst promesa = new Promise((resolve, reject) =&gt; {\n  // simulamos una operación que falla\n  reject(\"Error en la operación\");\n});\n\npromesa.catch((error) =&gt; {\n  console.error(error); // \"Error en la operación\"\n});\nEn este ejemplo, el método catch() se llama con una función que recibe el error como parámetro. La función se ejecuta cuando la promesa se rechaza y se imprime el error en la consola.\n\n\n\nEl encadenamiento de promesas es una técnica que permite combinar varias operaciones asíncronas en una sola cadena de promesas. Esto permite manejar operaciones complejas de manera más fácil y legible.\nLa idea básica es que cada promesa devuelve otra promesa, lo que permite encadenar varias operaciones asíncronas. El método then() devuelve una nueva promesa que se puede utilizar para encadenar otra operación.\nAquí hay un ejemplo:\nconst promesa1 = new Promise((resolve, reject) =&gt; {\n  // simulamos una operación que tarda 2 segundos\n  setTimeout(() =&gt; {\n    resolve(\"Operación 1 completada con éxito\");\n  }, 2000);\n});\n\nconst promesa2 = promesa1.then((resultado) =&gt; {\n  console.log(resultado); // \"Operación 1 completada con éxito\"\n  return new Promise((resolve, reject) =&gt; {\n    // simulamos otra operación que tarda 3 segundos\n    setTimeout(() =&gt; {\n      resolve(\"Operación 2 completada con éxito\");\n    }, 3000);\n  });\n});\n\npromesa2.then((resultado) =&gt; {\n  console.log(resultado); // \"Operación 2 completada con éxito\"\n});\nEn este ejemplo, promesa1 se resuelve después de 2 segundos y devuelve una cadena de texto. Luego, promesa1 se pasa al método then(), que devuelve promesa2. promesa2 se resuelve después de 3 segundos y devuelve otra cadena de texto.\nEl encadenamiento de promesas permite manejar operaciones asíncronas de manera más fácil y legible. En lugar de tener que anidar callbacks dentro de callbacks, se pueden encadenar promesas para crear una cadena de operaciones asíncronas.\nVentajas del encadenamiento de promesas\nEl encadenamiento de promesas tiene varias ventajas:\n\nMejora la legibilidad del código: el código es más fácil de leer y entender.\nReduce la complejidad: el encadenamiento de promesas reduce la complejidad del código y hace que sea más fácil de mantener.\nMejora la gestión de errores: el encadenamiento de promesas permite manejar errores de manera más efectiva.\n\nAhora vamos a usar una promesa con catch error en el contexto de usar una API (application programming interface) para que quede más claro como se usan en la práctica\nfetch('https://api.example.com/users/1')\n .then(response =&gt; response.json())\n .then(usuario =&gt; {\n    console.log(`Nombre del usuario: ${usuario.name}`);\n  })\n .catch(error =&gt; {\n    console.error(`Error: ${error}`);\n  });\nEn este ejemplo, como hemos comentado usa el método then que devuelve una nueva promesa que se puede utilizar para encadenar otra operación. Si la llamada funciona, la promesa se transforma a json, luego se extrae nombre del usuario y se imprime en consola. Si no funciona la llamda debido a un problema de red o de API se atrapa y se imprime. Hay que tomar en cuenta que cuando ocurre un problema es muy importante saber interpretarlo. Los tipos de errores mas comunes y su significado se pueden ver en la siguiente figura:\n\n\n\nHTTP status code\n\n\n\n\n\nUn objeto Promesa en JavaScript puede estar en uno de los siguientes estados:\n\nPending (Pendiente): Es el estado inicial de la promesa, cuando se está ejecutando la operación asíncrona. En este estado, el resultado es undefined.\nFulfilled (Cumplida): Es el estado en el que la promesa se ha resuelto con éxito. En este estado, el resultado es un valor.\nRejected (Rechazada): Es el estado en el que la promesa se ha rechazado con un error. En este estado, el resultado es un objeto de error.\n\n\n\n\nUn objeto Promesa tiene dos propiedades:\n\nState (Estado): Indica el estado actual de la promesa (Pending, Fulfilled o Rejected).\nResult (Resultado): Es el valor o error que se devuelve cuando la promesa se resuelve o rechaza.\n\nReferencias\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\nhttps://www.w3schools.com/js/js_promise.asp\nhttps://www.linkedin.com/pulse/http-response-status-codes-mominur-rahman-yl89c/\nhttps://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status"
  }
]