---
title: "JS - CKP8"
---

# Cuestionario - Javascript

![JS icon](images/js.png)

## ¿Qué tipo de bucles hay en JS?

Los bucles son una manera de repetir un proceso. Los bucles más comunes son:

* **For**: itera sobre una secuencia de elementos, como un array o un objeto.
* **While**: repite proceso mientras se cumple una condición.Si no se cumple, no se corre el proceso ninguna vez.
* **Do-While**: similar al bucle While, pero se ejecuta al menos una vez antes de evaluar la condición.


Referencias

<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration>

## ¿Cuáles son las diferencias entre const, let y var?

En JavaScript, const, let y var se utilizan para declarar variables, pero tienen diferencias clave en su alcance y comportamiento (hoisting, reglas de reasignación):

Hoisting: Es un comportamiento donde las declaraciones de variables se mueven a la parte superior del ambito en el que se declaran.

**var**: La variable declarada con var tiene un alcance de función o global, es decir, se aplica a toda la función en la que se declara. Puede ser redeclarada y reasignada.

``` default
var persona = { nombre: "Ana", edad: 28 };

var persona = { nombre: "Fran", edad: 25 };

```

Ejemplo de Hoisting para var donde se tiene:

``` default

console.log(x); // undefined
var x = 10;

```
Debido al hoisting, el código se ejecuta como si fuera la variable declarada y no asignada hasta después:

``` default
var x;
console.log(x); // undefined
x = 10;

```

**let**: La variable declarada con let tiene un alcance de bloque, es decir, se aplica solo dentro del bloque en el que se declara. Puede ser reasignada, pero no redeclarada.

En el siguiente ejemplo se observa como si se llama a una variable declarada dentro de función y se intenta llamar fuera del bloque nos da error:

``` default
if (true) {
    let nombre = "Juan";
    console.log(nombre);
}
console.log(nombre); // Error: nombre is not defined

```
En otro ejemplo se usa let para declarar una variable global y luego otra local (dentro de función):

``` default
let edad = 25;
if (true) {
    let edad = 30; 
    console.log(edad); // 30
}
console.log(edad); // 25

```
Se observa como la variable local solo es accesible dentro del bloque if y no afecta a la variable global.

Hoisting para let funciona diferente que para var, ya que que con let no se inicializa la variable y causa un error:


``` default
console.log(number)
// ReferenceError: Cannot access 'number' before initialization

let number = 50
```


**const**: La variable declarada con const también tiene un alcance de bloque, pero no puede ser reasignada ni redeclarada. Su valor es constante.

``` default
const edad = 30; 
edad = 35; // Error: Assignment to constant variable.

```
Hoisting para const es similar que para let donde no se inicializa variable y da error:

``` default
console.log(number)
// ReferenceError: Cannot access 'number' before initialization

const number = 50

```

Debido a que usar variables antes de declararlas puede causar problemas, algunas veces se recomienda seguir la regla **no-use-before-define** o lo que es definir primero y hasta después usar.


Referencias

<https://www.geeksforgeeks.org/difference-between-var-let-and-const-keywords-in-javascript/>

<https://www.freecodecamp.org/news/differences-between-var-let-const-javascript/>

<https://eslint.org/docs/latest/rules/no-use-before-define>



## ¿Qué es una función de flecha?

Una función flecha es una forma concisa de definir una función en JavaScript. Se utiliza la sintaxis () => {} para crear una función anónima.

Ejemplo de una función normal (function declaration) que suma dos números:

``` default
function sumar(a, b) {
  return a + b;
}

```

La versión con función anónima:

``` default
var sumar = function(a, b) {
  return a + b;
}

```

Ahora miramos versión de función flecha equivalente:


``` default
const sumar = (a, b) => a + b;
console.log(sumar(2, 3)); // 5
```
**Variantes**

Hay algunas variantes, por ejemplo los parentesis en los argumentos. En la función anterior usamos como argumentos (a,b) que nos regresa el resultado de expresión (a+b) pero en caso de que hubiera un solo argumento, los parentesis pueden ser omitidos. Por ejemplo en la siguiente expression la función puede ser escrita con o sin parentesis.

``` default
let double = n => n * 2;
// igual que: let double = (n) => n * 2;
// Muy similar a funcion anónima: let double = function(n) { return n * 2 }

alert( double(3) ); // 6
```

En caso de que no hubiera argumentos, los parentesis tienen que estar vacios. Por ejemplo:

``` default
let saluda = () => alert("Hola");
saluda();
```

**Multilinea**.En caso de que se tenga que realizar varias expresiones dentro de la función se usa "{}" para englobar la diferentes lineas y se debe incluir "return" para que nos regrese algo, justo como en función normal. Veamos un ejemplo donde se evalua que los valores pasados a función son positivos y luego calcula el área:

``` default
const calcularArea = (base, altura) => {
  if (base <= 0 || altura <= 0) {
    throw new Error("La base y la altura deben ser números positivos");
  }
  const area = base * altura;
  return area;
}
```




**Cuándo usar funciones flecha**

Se recomienda usar funciones flecha en los siguientes casos:

- Funciones cortas y simples: Cuando la función es muy simple y no requiere una gran cantidad de código, las funciones flecha son ideales.
- Callbacks: Las funciones flecha son útiles como callbacks, ya que son más concisas y fáciles de leer.
- Funciones anónimas: Las funciones flecha son una forma natural de crear funciones anónimas.
- Map, filter, reduce: Las funciones flecha son ideales para usar con métodos de arrays como map, filter y reduce.

Ejemplo de uso con map:

``` default
const numbers = [1, 2, 3, 4, 5];
const doubles = numbers.map((num) => num * 2);
console.log(doubles); // [2, 4, 6, 8, 10]

```



Referencias

<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions>

<https://www.w3schools.com/js/js_arrow_function.asp>

<https://javascript.info/arrow-functions-basics>

## ¿Qué es la deconstrucción de variables?

![Tomado de www.samanthaming.com](images/js_deconstruction.png)

La deconstrucción de variables es una forma de asignar valores a variables a partir de un objeto o un array. 

Se utiliza la sintaxis para objeto:
      `{ variable1, variable2, ... } = objeto`

Se utiliza la sintaxis para array:
      `[variable1, variable2, ...] = array`.
      
La deconstrucción de variables es útil para simplificar el código y evitar la necesidad de acceder a las propiedades de un objeto o los elementos de un array mediante su índice o nombre.

Veamos como funciona con algunos ejemplos:

```javascript
// Deconstrucción de objeto
const persona = { nombre: "Juan", edad: 30 };
const { nombre, edad } = persona;

console.log(nombre); // Output: "Juan"
console.log(edad); // Output: 30

```

Y para un array tenemos:
```javascript
// Deconstrucción de array
const frutas = ["manzana", "banana", "naranja"];
const [fruta1, fruta2, fruta3] = frutas;

console.log(fruta1); // Output: "manzana"
console.log(fruta2); // Output: "banana"
console.log(fruta3); // Output: "naranja"
```

**Valores predeterminados**

A una variable se le puede asignar un valor predeterminado, en el caso de que el valor desempacado del arreglo sea undefined.

Veamos un ejemplo para objeto donde se desestructura el objeto persona y se asignan valores predeterminados a las variables nombre, edad y pais. Si el objeto persona no tiene una propiedad con el nombre correspondiente, se asigna el valor predeterminado.

```javascript
const persona = { nombre: "Juan", edad: 30 };
const { nombre = "Desconocido", edad = 0, pais = "No especificado" } = persona;

console.log(nombre); // "Juan"
console.log(edad);   // 30
console.log(pais);   // "No especificado"
```
Ahora veamos un ejemplo usando array donde se desestructura el array colores y se asignan valores predeterminados a las variables primero, segundo y tercero. Si el array colores no tiene suficientes elementos, se asignan los valores predeterminados a las variables restantes.

``` default
const colores = ["rojo", "azul"];
const [primero = "negro", segundo = "blanco", tercero = "gris"] = colores;

console.log(primero); // "rojo"
console.log(segundo); // "azul"
console.log(tercero); // "gris"

```

**Ignorar valores devueltos**

Se puede ignorar los valores que no interesan para evitar crear variables que no se usan y hay varias opciones. Aqui unos ejemplos:

``` default
// ❌ Malo, asignación de variable inútil
const [ignore, keep] = ['ignore', 'keep']; // La variable "ignore" no se utiliza

// ✅ Bueno, espacio en blanco
const [, keep] = ['ignore', 'keep']; // Se ignora el primer valor

// ✅ Bueno, guion bajo
const [_ignore, keep] = ['ignore', 'keep']; // Se ignora el primer valor y se indica con "_"

``` 


Referencias

<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring>

<https://www.w3schools.com/js/js_destructuring.asp>

<https://dmitripavlutin.com/javascript-object-destructuring/>

<https://www.samanthaming.com/tidbits/13-skip-values-in-destructuring/>

## ¿Qué hace el operador de extensión en JS?

El operador de extensión o spread syntax(`...`)  se utiliza para expandir un array o un objeto en una nueva estructura de datos. La sintaxis extendida permite a un elemento iterable tal como un arreglo o cadena ser expandido en lugares donde cero o más argumentos (para llamadas de función) o elementos (para Array literales) son esperados, o a un objeto ser expandido en lugares donde cero o más pares de valores clave (para literales Tipo Objeto) son esperados.

```javascript
// Expansión de array
const numeros = [1, 2, 3];
const nuevosNumeros = [...numeros, 4, 5, 6];

console.log(nuevosNumeros); // Output: [1, 2, 3, 4, 5, 6]

// Expansión de objeto
const persona = { nombre: "Juan", edad: 30 };
const nuevaPersona = { ...persona, direccion: "Calle 123" };

console.log(nuevaPersona); // Output: { nombre: "Juan", edad: 30, direccion: "Calle 123" }
```
El operador de extensión es útil para crear copias de arrays y objetos, y para combinar datos de diferentes fuentes.


**Crear copias**

En el contexto de crear copias, se utiliza para crear una copia superficial de un array o un objeto.

- Copiar arrays

Para copiar un array, puedes utilizar el operador de propagación de la siguiente manera:

```javascript
const original = [1, 2, 3];
const copia = [...original];

console.log(copia); // [1, 2, 3]

```

En este ejemplo, se crea una copia del array original utilizando el operador de propagación (...). La copia se almacena en la variable copia.

- Copiar objetos

De manera similar, puedes copiar un objeto utilizando el operador de propagación:

```javascript
const original = { a: 1, b: 2 };
const copia = { ...original };

console.log(copia); // { a: 1, b: 2 }
```

Si te preguntas que es una copia superficial aqui se explica. La copia creada con el operador de propagación se llama "copia superficial" (o "shallow copy" en inglés) porque solo copia los valores de las propiedades del objeto o los elementos del array de manera directa, sin copiar los objetos o arrays anidados.

En otras palabras, si el objeto o array original contiene referencias a otros objetos o arrays, la copia solo copiará las referencias, no los objetos o arrays en sí mismos. Esto significa que si se modifica el objeto o array original, la copia también se verá afectada, ya que ambos comparten las mismas referencias.

Aquí hay un ejemplo:

```javascript

const original = {
  a: 1,
  b: [2, 3],
  c: { d: 4 }
};

const copia = { ...original };

copia.b.push(5);
copia.c.d = 6;

console.log(original); // { a: 1, b: [2, 3, 5], c: { d: 6 } }
console.log(copia); // { a: 1, b: [2, 3, 5], c: { d: 6 } }

```

En este ejemplo, el objeto original se ve afectada por las modificaciones realizadas en el objeto copia, ya que ambos comparten las mismas referencias a los arrays y objetos anidados.

Para crear una copia profunda (o "deep copy") que no comparta referencias con el objeto original, se necesitan técnicas más avanzadas, como la recursividad o la utilización de bibliotecas como Lodash

**Combinar datos**

El operador de propagación (spread syntax) también se puede utilizar para combinar datos de diferentes fuentes en un nuevo array o objeto.

- Combinar arrays

Para combinar dos o más arrays, puedes utilizar el operador de propagación de la siguiente manera:

```javascript
const array1 = [1, 2, 3];
const array2 = [4, 5, 6];

const combinado = [...array1, ...array2];

console.log(combinado); // [1, 2, 3, 4, 5, 6]

```

En este ejemplo, se combinan los arrays array1 y array2 en un nuevo array llamado combinado.

- Combinar objetos

De manera similar, puedes combinar dos o más objetos utilizando el operador de propagación:

```javascript
const objeto1 = { a: 1, b: 2 };
const objeto2 = { c: 3, d: 4 };

const combinado = {...objeto1, ...objeto2};

console.log(combinado); // { a: 1, b: 2, c: 3, d: 4 }

```

En este ejemplo, se combinan los objetos objeto1 y objeto2 en un nuevo objeto llamado combinado.

Combinar arrays y objetos.También puedes combinar arrays y objetos utilizando el operador de propagación:

```javascript
const array = [1, 2, 3];
const objeto = { a: 4, b: 5 };

const combinado = [...array, objeto];

console.log(combinado); // [1, 2, 3, { a: 4, b: 5 }]

```

En este ejemplo, se combina el array array con el objeto objeto en un nuevo array llamado combinado.

Sobrescritura de propiedades

Cuando se combinan objetos utilizando el operador de propagación, si dos o más objetos tienen propiedades con el mismo nombre, la propiedad del objeto que se combina en segundo lugar sobrescribirá la propiedad del objeto que se combina en primer lugar.

Aquí hay un ejemplo:

```javascript
const objeto1 = { a: 1, b: 2 };
const objeto2 = { b: 3, c: 4 };

const combinado = {...objeto1, ...objeto2};

console.log(combinado); // { a: 1, b: 3, c: 4 }

```

En este ejemplo, la propiedad b del objeto objeto2 sobrescribe la propiedad b del objeto objeto1, por lo que el valor de b en el objeto combinado es 3, no 2.

Es importante tener en cuenta que esto se aplica a todas las propiedades que se combinan, no solo a las que tienen el mismo nombre. Si un objeto tiene una propiedad que no existe en el otro objeto, se agregará al objeto combinado sin problemas.

Aquí hay un ejemplo con múltiples objetos:

```javascript
const objeto1 = { a: 1, b: 2 };
const objeto2 = { b: 3, c: 4 };
const objeto3 = { c: 5, d: 6 };

const combinado = {...objeto1, ...objeto2, ...objeto3};

console.log(combinado); // { a: 1, b: 3, c: 5, d: 6 }

```

En este ejemplo, la propiedad b del objeto objeto2 sobrescribe la propiedad b del objeto objeto1, y la propiedad c del objeto objeto3 sobrescribe la propiedad c del objeto objeto2. El objeto combinado tiene las propiedades de todos los objetos, con las sobrescrituras correspondientes.

**En llamadas de función**

El operador de propagación (spread syntax) se puede utilizar en llamadas de función para pasar argumentos de manera flexible y conveniente.

Pasar argumentos como array

En JavaScript, cuando se llama a una función, se pueden pasar argumentos de manera individual, como en el siguiente ejemplo:

```javascript
function suma(a, b, c) {
  return a + b + c;
}

const resultado = suma(1, 2, 3);
console.log(resultado); // 6
```

Sin embargo, si se tiene un array de valores que se desean pasar como argumentos, se puede utilizar el operador de propagación para "desempacar" el array y pasar sus elementos como argumentos individuales:

```javascript
function suma(a, b, c) {
  return a + b + c;
}

const valores = [1, 2, 3];
const resultado = suma(...valores);
console.log(resultado); // 6

```

En este ejemplo, el operador de propagación (...) se utiliza para "desempacar" el array valores y pasar sus elementos como argumentos individuales a la función suma.

otra aplicación importante del operador de propagación en funciones: permitir que una función acepte un número variable de argumentos.

Funciones con un número variable de argumentos

En JavaScript, se puede definir una función que acepte un número variable de argumentos utilizando el operador de propagación en la lista de parámetros. Esto se conoce como "rest parameter" (parámetro de resto).

Aquí hay un ejemplo:

```javascript
function suma(...numeros) {
  return numeros.reduce((a, b) => a + b, 0);
}

console.log(suma(1, 2, 3)); // 6
console.log(suma(1, 2, 3, 4, 5)); // 15

```

En este ejemplo, la función suma acepta un número variable de argumentos, que se almacenan en el array numeros. La función utiliza el método reduce para sumar todos los números en el array y devolver el resultado.

El operador de propagación (...) se utiliza para indicar que el parámetro numeros es un parámetro de resto, que puede aceptar cualquier número de argumentos.

De esta manera, la función suma puede ser llamada con cualquier número de argumentos, y siempre devolverá la suma de todos los números pasados como argumentos.

Otro ejemplo

Aquí hay otro ejemplo de una función que utiliza el operador de propagación para aceptar un número variable de argumentos:

```javascript

function max(...numeros) {
  return Math.max(...numeros);
}

console.log(max(1, 2, 3)); // 3
console.log(max(1, 2, 3, 4, 5)); // 5

```

En este ejemplo, la función max acepta un número variable de argumentos y devuelve el máximo de todos los números pasados como argumentos.


Referencias

<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax>

<https://www.w3schools.com/howto/howto_js_spread_operator.asp>

<https://lodash.com/>

<https://www.geeksforgeeks.org/lodash-_-clonedeep-method/>



## ¿Qué es la programación orientada a objetos?


La programación orientada a objetos (POO) es un paradigma de programación que se centra en la creación de objetos que tienen propiedades y métodos que describen su comportamiento. En JavaScript, la POO se utiliza para crear objetos que pueden interactuar entre sí y con otros objetos.

**Creación de objetos en JavaScript**

En JavaScript, los objetos se pueden crear de dos maneras:

1. Sintaxis de objeto literal.

Esta es la forma más común de crear objetos en JavaScript. Se utiliza la sintaxis {} para crear un objeto y se pueden agregar propiedades y métodos utilizando la sintaxis clave: valor

```javascript
// Ejemplo de objeto en JavaScript
const persona = {
  nombre: "Ernesto",
  edad: 41,
  profesion: "ingeniero ambiental",
  saludar: function() {
	console.log(`Hola, me llamo ${this.nombre}, tengo ${this.edad} años y trabajo como ${profesion}`);
  }
};

persona.saludar(); // Output: "Hola, me llamo Ernesto, tengo 41 años y trabajo como ingeniero ambiental"
```
En este ejemplo, se crea un objeto persona con tres propiedades: nombre, edad, profesión y el método saludar. La propiedad saludar es un método que se puede llamar para saludar.

2. Constructores.

Los constructores son funciones especiales que se utilizan para crear objetos. Se utilizan la palabra clave new para crear un objeto a partir de un constructor.

```javascript
function Persona(nombre, edad, profesion) {
  this.nombre = nombre;
  this.edad = edad;
  this.profesion = profesion;
  this.saludar = function() {
    console.log(`Hola, me llamo ${this.nombre}`);
  };
}

const persona = new Persona('Ines', 30, "Doctora");

```

En este ejemplo, se define un constructor Persona que toma tres parámetros: nombre, edad y profesión. El constructor crea un objeto con las propiedades nombre, edad, profesión y el método saludar. Luego, se crea un objeto persona utilizando el constructor Persona y la palabra clave new.

**Diferencias entre la sintaxis de objeto literal y los constructores**

La principal diferencia entre la sintaxis de objeto literal y los constructores es la forma en que se crean los objetos. La sintaxis de objeto literal es más concisa y fácil de leer, mientras que los constructores ofrecen más flexibilidad y permiten la creación de objetos con propiedades y métodos dinámicos.


**Herencia**

La herencia es un concepto fundamental en la Programación Orientada a Objetos (OOP) que permite crear una nueva clase a partir de una clase existente, heredando sus propiedades y métodos. En JavaScript, la herencia se puede implementar utilizando la palabra clave extends y la función constructor.

Ejemplo de herencia

Supongamos que tenemos una clase Vehiculo que tiene propiedades como marca, modelo y año, y métodos como arrancar y detener. Queremos crear una clase Coche que herede las propiedades y métodos de Vehiculo y agregue algunas propiedades y métodos adicionales.

```javascript
// Clase Vehiculo
class Vehiculo {
  constructor(marca, modelo, año) {
    this.marca = marca;
    this.modelo = modelo;
    this.año = año;
  }

  arrancar() {
    console.log(`El vehículo ${this.marca} ${this.modelo} está arrancando`);
  }

  detener() {
    console.log(`El vehículo ${this.marca} ${this.modelo} está deteniendo`);
  }
}

// Clase Coche que hereda de Vehiculo
class Coche extends Vehiculo {
  constructor(marca, modelo, año, puertas) {
    super(marca, modelo, año);
    this.puertas = puertas;
  }

  abrirPuertas() {
    console.log(`Se abren las ${this.puertas} puertas del coche ${this.marca} ${this.modelo}`);
  }
}
```

La clase Coche hereda de Vehiculo utilizando la palabra clave extends. El constructor de Coche llama al constructor de Vehiculo utilizando la función super, pasando los parámetros marca, modelo y año. Luego, inicializa la propiedad puertas propia de la clase Coche.

La función super se utiliza para llamar al constructor de la clase padre (en este caso, Vehiculo) y heredar sus propiedades y métodos. De esta manera, la clase Coche tiene acceso a las propiedades y métodos de Vehiculo, como marca, modelo, año, arrancar y detener, y puede agregar sus propias propiedades y métodos, como puertas y abrirPuertas.

A continuación se presenta ejemplo de como usar clase Coche que hereda de vehiculo:

```javascript
// Crear un objeto de la clase Coche
const miCoche = new Coche('Toyota', 'Corolla', 2015, 4);

// Llamar a los métodos heredados de Vehiculo
miCoche.arrancar(); // El vehículo Toyota Corolla está arrancando
miCoche.detener(); // El vehículo Toyota Corolla está deteniendo

// Llamar al método propio de Coche
miCoche.abrirPuertas(); // Se abren las 4 puertas del coche Toyota Corolla

// Acceder a las propiedades
console.log(miCoche.marca); // Toyota
console.log(miCoche.modelo); // Corolla
console.log(miCoche.año); // 2015
console.log(miCoche.puertas); // 4
```

En este ejemplo, creamos un objeto miCoche de la clase Coche, pasando los parámetros marca, modelo, año y puertas. Luego, llamamos a los métodos heredados de Vehiculo, como arrancar y detener, y al método propio de Coche, como abrirPuertas.

Referencias

<https://www.w3schools.com/js/js_object_constructors.asp>

<https://keepcoding.io/blog/que-es-this-en-javascript/>

<https://www.geeksforgeeks.org/introduction-object-oriented-programming-javascript/>

[https://medium.com/\@leoanimesh/javascript-this-keyword-explained-a62f3676fca1](https://medium.com/@leoanimesh/javascript-this-keyword-explained-a62f3676fca1){.uri}

## ¿Qué es una promesa en JS?

## ¿Qué hacen async y await por nosotros?

## Ejercicios

### Ejercicio 1

Crea un bucle for en JS que imprima cada nombre en esta lista.

```         
  miLista = “velma”, “exploradora”, “jane”, “john”, “harry”
```

Crea un bucle while que recorra la misma lista y también imprima los nombres. Nota: Recuerda crear un contador para que el ciclo no sea infinito.

```{ojs}
// ejercicio.js

/*crea funcion que toma 4 argumentos, suma los 2 primeros y multiplica los 2 siguientes
Si el número creado es mayor que 50, la consola registra "¡El número es mayor que 50!". 
Si es más pequeño, la consola registra "¡El número es menor que 50!"
*/
function myFunctionSumaMultiplica(num1, num2,num3,num4) {
    
// Verificar que se hayan pasado exactamente 4 argumentos
if (arguments.length !== 4) {
    console.log("Error de cantidad: se deben pasar 4 argumentos.");
    return;
}

// Verificar que todos sean números
if (
    typeof num1 !== 'number' ||
    typeof num2 !== 'number' ||
    typeof num3 !== 'number' ||
    typeof num4 !== 'number'
) {
    console.log("Error de tipo: todos los 4 argumentos deben ser números.");
    return;
}
    
    let suma1 = num1 + num2;
    let suma2 = num3 + num4;
    let producto = suma1 * suma2;
    if (producto > 50) {
        console.log(`¡El número ${producto} es mayor que 50!`);
    }
    else if (producto === 50) {
        console.log(`¡El número ${producto} es igual a 50!`);
    }
    else {
        console.log(`¡El número ${producto} es menor que 50!`);
    }

    
  }

//llama a la funcion y muestra el resultado en consola
//var resultado = myFunctionSumaMultiplica(2.5, 3, 4, 2);

// ejemplo con error de tipo
//var resultado2 = myFunctionSumaMultiplica(2.5, 3, "4", 2);
// ejemplo con error de cantidad de argumentos
//var resultado3 = myFunctionSumaMultiplica(2.5, 3, 4);



```

[Enlace a fichero JS](https://github.com/inti-documentation/inti-documentation.github.io/blob/main/checkpoint8_ejercicio1.js)

### Ejercicio 2

Cree una función de flecha que devuelva "Hola mundo".

[Enlace a fichero JS](https://github.com/inti-documentation/inti-documentation.github.io/blob/main/checkpoint8_ejercicio2.js)
